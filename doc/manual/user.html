<?xml version="1.0" encoding="iso-8859-1" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML Basic 1.0//EN"
"http://www.w3.org/TR/xhtml-basic/xhtml-basic10.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<link title="Purple" rel="stylesheet" href="manual-purple.css" type="text/css" />
<link title="Minty" rel="alternate stylesheet" href="manual-minty.css" type="text/css" />
<link title="Plain" rel="alternate stylesheet" href="manual.css" type="text/css" />
<title>openMSX User's Manual</title>
</head>

<body>

<h1>openMSX User's Manual</h1>

<h2>Contents</h2>

<ol class="toc">
	<li><a class="internal" href="#intro">1. Introduction</a>
		<ol class="toc">
			<li><a class="internal" href="#newver">1.1 New Versions of this Document</a></li>
			<li><a class="internal" href="#purpose">1.2 Purpose</a></li>
			<li><a class="internal" href="#contrib">1.3 Contributors</a></li>
			<li><a class="internal" href="#history">1.4 Revision History</a></li>
		</ol>
	</li>
	<li><a class="internal" href="#starting">2. Starting the Emulator</a>
		<ol class="toc">
			<li><a class="internal" href="#machines">2.1 Machines</a></li>
			<li><a class="internal" href="#extensions">2.2 Extensions</a></li>
			<li><a class="internal" href="#otheroptions">2.3 Other Command Line Options</a></li>
		</ol>
	</li>
	<li><a class="internal" href="#controlling">3. The Console and Settings</a>
		<ol class="toc">
			<li><a class="internal" href="#console">3.1 Console Introduction</a></li>
			<li><a class="internal" href="#importantconsole">3.2 Some Simple Console Commands</a></li>
			<li><a class="internal" href="#settings">3.3 Settings</a></li>
			<li><a class="internal" href="#plug">3.4 Plug</a></li>
			<li><a class="internal" href="#trainer">3.5 Game Trainer</a></li>
		</ol>
	</li>
	<li><a class="internal" href="#media">4. Running MSX Software and Using Media</a>
		<ol class="toc">
			<li><a class="internal" href="#roms">4.1 Running ROM Software</a></li>
			<li><a class="internal" href="#disks">4.2 Running Disk Software</a>
				<ol class="toc">
					<li><a class="internal" href="#diskimages">4.2.1 Using Disk Images</a></li>
					<li><a class="internal" href="#dirasdisk">4.2.2 Using Directories as Disks</a></li>
					<li><a class="internal" href="#realdisks">4.2.3 Using Real Disks</a></li>
					<li><a class="internal" href="#harddisks">4.2.4 Emulating MSX Harddisks</a></li>
				</ol>
			</li>
			<li><a class="internal" href="#tape">4.3 Running Tape Software</a>
				<ol class="toc">
					<li><a class="internal" href="#tapewav">4.3.1 Using WAV files</a></li>
					<li><a class="internal" href="#cas">4.3.2 Using CAS files</a></li>
					<li><a class="internal" href="#tapejack">4.3.3 Using Jack audio connection kit</a></li>
				</ol>
			</li>
		</ol>
	</li>

	<li><a class="internal" href="#input">5. Input Devices</a>
		<ol class="toc">
			<li><a class="internal" href="#keymapping">5.1 Key Mapping</a>
				<ol class="toc">
					<li><a class="internal" href="#keymappingpc">5.1.1 Key Mapping on PC</a></li>
					<li><a class="internal" href="#keymappingmac">5.1.2 Key Mapping on Mac OS X</a></li>
				</ol>
			</li>
			<li><a class="internal" href="#joystick">5.2 Joystick</a></li>
			<li><a class="internal" href="#mouse">5.3 Mouse</a></li>
		</ol>
	</li>

	<li><a class="internal" href="#video">6. Video</a>
		<ol class="toc">
			<li><a class="internal" href="#renderers">6.1 Renderers</a></li>
			<li><a class="internal" href="#accuracy">6.2 Accuracy</a></li>
			<li><a class="internal" href="#scalers">6.3 Scalers</a></li>
			<li><a class="internal" href="#gamma">6.4 Gamma Correction</a></li>
			<li><a class="internal" href="#videoeffects">6.5 Special Effects</a></li>
			<li><a class="internal" href="#gfx9000">6.6 GFX9000/Video sources</a></li>
			<li><a class="internal" href="#recording">6.7 Video recording</a></li>
		</ol>
	</li>

	<li><a class="internal" href="#audio">7. Audio</a>
		<ol class="toc">
			<li><a class="internal" href="#audiosettings">7.1 Audio Settings</a></li>
			<li><a class="internal" href="#midi">7.2 MIDI</a></li>
			<li><a class="internal" href="#soundlogger">7.3 Recording Audio to File</a></li>
		</ol>
	</li>

	<li><a class="internal" href="#debugdevice">8. Debug Device</a>
		<ol class="toc">
			<li><a class="internal" href="#debugdeviceenable">8.1 Enabling the Debug Device</a></li>
			<li><a class="internal" href="#debugdeviceports">8.2 The Output Ports</a></li>
			<li><a class="internal" href="#debugdevicemode1">8.3 Single Byte Mode</a></li>
			<li><a class="internal" href="#debugdevicemode2">8.4 Multi Byte Mode</a></li>
			<li><a class="internal" href="#debugdeviceoutput">8.5 Controlling the Output</a></li>
		</ol>
	</li>
	<li><a class="internal" href="#contact">9. Contact Info</a></li>
</ol>


<h2><a id="intro">1. Introduction</a></h2>

<h3><a id="newver">1.1 New Versions of this Document</a></h3>
<p>
The latest version of the openMSX manual can be found on the openMSX home page:
</p>
<p>
<a class="external" href="http://openmsx.sourceforge.net/manual/">http://openmsx.sourceforge.net/manual/</a>
</p>
<p>
You can also use this URL to get up-to-date versions of the hyper links
if you printed out this manual.
</p>

<h3><a id="purpose">1.2 Purpose</a></h3>
<p>
This manual is about openMSX, the open source MSX emulator that tries to achieve
near-perfect emulation by using a novel emulation model.
You can find more information about openMSX on the
<a class="external" href="http://openmsx.sourceforge.net/">openMSX home page</a>.
You can also download the emulator itself from there.
</p>

<p>
openMSX is in alpha state, which means that some things work but not all
features are implemented yet.
Many emulation features are implemented, but in terms of user interface
it is rather bare bones, unless you use the optional Graphical User Interface dubbed openMSX Catapult, which has separate <a class="external" href="http://openmsx.sourceforge.net/catapult-manual/">manuals</a> for now.
However, because the emulation is already pretty good,
it would be nice if non-insiders would be able to play with it, too.
For those people, we have written this guide.
It explains how you can make use of the features of the emulator, once you have got it running.
</p>

<p>
This manual tells you how you can use openMSX, once it has been installed and properly set up. You should be able to use most of the features of openMSX if you have read it.
If you are using using openMSX with Catapult, you don't have to pay attention to the exact command and setting names. However it is still useful to read this document to find out how openMSX works and learn its terminology.
</p>

<p>
<em>Disclaimer:</em>
We do not claim this guide is complete or even correct.
What you do with the information in it is entirely at your own risk.
We just hope it helps you enjoy openMSX more.
</p>

<h3><a id="contrib">1.3 Contributors</a></h3>

<p>
The following people contributed to this document in one way or another:
</p>
<ul>
<li>Jorrith Schaap</li>
<li>Manuel Bilderbeek</li>
<li>Maarten ter Huurne</li>
<li>other openMSX developers</li>
</ul>
<p>
Thanks to all of them!
</p>

<h3><a id="history">1.4 Revision History</a></h3>

<p>
This section gives an overview of the changes that were made to this document.
It doesn't contain every single modification (use the  <a class="external"
href="http://svn.sourceforge.net/viewvc/openmsx/openmsx/trunk/doc/manual/user.html?view=log">SVN log</a> for that),
only the big picture.
</p>

<dl>
<dt>2006-07-01: Manuel Bilderbeek</dt>
<dd>
Updates for version 0.6.1.
</dd>

<dt>2005-05-12: Manuel Bilderbeek</dt>
<dd>
Updates for version 0.5.2.
</dd>

<dt>2005-01-26: Manuel Bilderbeek</dt>
<dd>
Updates for version 0.5.1.
</dd>

<dt>2004-09-28: Manuel Bilderbeek</dt>
<dd>
Updates for version 0.5.0, including some more elaborate explanations for several subjects.
</dd>

<dt>2004-05-20: Maarten ter Huurne</dt>
<dd>
Updates for version 0.4.0: restructured chapters and added more info about video settings.
</dd>

<dt>2004-01-16: Manuel Bilderbeek</dt>
<dd>
Updates for version 0.3.4: explanation of the scalers was added.
</dd>

<dt>2003-09-25: Maarten ter Huurne and Manuel Bilderbeek</dt>
<dd>
Split the User's Manual off from the openMSX HOWTO.
Converted to XHTML.
Restructured the document.
Rewrote some text to fit better in the new structure and format.
</dd>

<dt>2002, 2003: Manuel Bilderbeek &amp; others</dt>
<dd>
Various updates to the HOWTO.
</dd>

<dt>2002: Manuel Bilderbeek &amp; Jorrith Schaap</dt>
<dd>
Original text written as part of the openMSX HOWTO.
</dd>

</dl>

<h2><a id="starting">2. Starting the Emulator</a></h2>

<p>
In this chapter we will tell you how to select MSX machines and how to use extension cartridges.
</p>

<h3><a id="machines">2.1 Machines</a></h3>

<p>
If you start openMSX without any command line parameters, you will get the default machine, which is stored in the <code>default_machine</code> setting, see the <a class="external" href="setup.html#settings">Setup Guide</a>. If you did not change the default machine, you will get the C-BIOS MSX2+ machine.
</p>

<p>
To select a different MSX machine, you can use the <code>-machine</code> command line argument:
</p>
<div class="commandline">
    openmsx -machine Panasonic_FS-A1GT
</div>
<p>
But, you can also use the <code>machine</code> command to switch at run time in the console, which is explained in the next chapter.
</p>

<p>
The C-BIOS machines come with ROMs installed; for other machines you will have to install system ROMs yourself, see the <a class="external" href="setup.html#systemroms">Setup Guide</a> for details.
</p>

<h3><a id="extensions">2.2 Extensions</a></h3>

<p>
Extensions are simply MSX cartridges (extensions to the MSX system) that you can plug into the emulated MSX. openMSX ships with a lot of predefined extensions. Note that many of them require firmware ROMs to be installed in the <code>share/extensions/<em>name</em>/roms</code> directory or in <code>share/systemroms</code>.
</p>
<p>
We will use the FMPAC as an example. openMSX ships with a definition (XML file) for the FMPAC extension, but you will have to add the <code>fmpac.rom</code> firmware ROM yourself. When you have done so, you can insert an FMPAC into the emulated MSX machine with the following command line:
</p>
<div class="commandline">
    openmsx -ext fmpac
</div>
<p>
Similar to machines, you can also use the <code>ext</code> command in the console to do it at run time.
</p>
<p>
If you look in the <code>share/extensions</code> directory, you will see all the extensions known to openMSX. For example <code>-ext mbstereo</code> gives you the MoonBlaster stereo effect: FMPAC on the left speaker and MSX-AUDIO on the right speaker.
</p>

<h3><a id="otheroptions">2.3 Other Command Line Options</a></h3>

<p>
Often used other command line options will be discussed later in this manual. For a complete list of them, type the following command:
</p>
<div class="commandline">openmsx -h</div>


<h2><a id="controlling">3. The Console and Settings</a></h2>

<h3><a id="console">3.1 Console Introduction</a></h3>

<p>
openMSX has a built-in command interface called the <em>console</em>,
which allows you to control almost all aspects of openMSX while it is running.
You can access the console by pressing F10
(with default key mapping) when the focus is on the emulator window.  This will
give you a command line in the openMSX window. Note that due to a <a class="external" href="http://sourceforge.net/tracker/index.php?func=detail&amp;aid=1157373&amp;group_id=38274&amp;atid=421861">known problem</a>
in SDL on Windows, the console won't come up if you went to fullscreen by using
ALT-ENTER. Use F12 to go to fullscreen to work around this problem. (See also 3.3: Settings and 5.1.1: Keymapping on a PC.)
</p>

<p>
Typing <code>help</code> gives a list of commands. Using PageUp you can see all of them.
If you type <code>help [command]</code> you will get help
for the specified command.
This manual describes a few important commands;
a full list can be found in the file <code>doc/commands.txt</code>.
The console can be used to change disk images, plug in joysticks or mice,
change settings at run time and to change key bindings, among others.
</p>

<p>
One very practical feature of the console command line is that you can use "completion" features. Just try typing half a command and then press the TAB key; openMSX will then try to finish the word you were typing or show the possibilities in case of ambiguities. You can use it also for file names, connectors, pluggables and settings, but also for machine and extension names.
</p>

<!--
<p class="todo">
Add the complete list of commands from commands.txt somewhere.
</p>
-->

<h3><a id="importantconsole">3.2 Some Simple Console Commands</a></h3>

<p>
You can reset your MSX with the Console command <code>reset</code> and exit openMSX with the command <code>exit</code>. As is explained in the previous chapter, you can change machines with the <code>machine</code> command and you can insert extensions with the <code>ext</code> command. Remove extensions with the <code>remove_extension</code> command or list them with the <code>list_extensions</code> command. Other commands will be discussed later on in this manual.
</p>

<h3><a id="settings">3.3 Settings</a></h3>

<p>
An interesting console command is <code>set</code>. You can use it to change the various
settings. E.g., you can use it to set the current renderer. If you issue set with only the setting (like <code>set renderer</code>), you will get the current value of that setting.
Settings that have only two possible values can also be toggled with the <code>toggle</code>
command (an example is the default key binding of F12 to <code>toggle
fullscreen</code>, see also below). A complete list of settings should also be in the file
<code>commands.txt</code> in the <code>doc</code> directory. Note that using the "tab completion" feature can help you a lot in getting an idea of what settings are possible, as it will only complete possible options. Just try that.
</p>
<!--
<p class="todo">
Add the complete list of settings in commands.txt somewhere.<br/>
</p>
-->

<p>
If the MSX goes too fast or too slow, adjust the emulation speed with the
<code>speed</code> setting, which has the speed percentage as parameter. So, typing <code>set
speed 120</code>, will let the emulated MSX run at 120% of normal MSX speed. This is useful for debugging purposes (slow down) or when you want to skip certain parts of a demo for example (speed up).
</p>

<p>
If you got the MSX sped up to maximum (<code>set throttle off</code>), but
openMSX is still not going fast enough for you, you can increase the
maxframeskip setting: <code>set maxframeskip 10</code> will mean that openMSX may
skip 10 screens to be displayed, just to get to the requested speed. Note that
you can also <em>force</em> openMSX to skip frames, with the minframeskip setting. This
sets the amount of frames that will be skipped always. Of course frame skipping
makes emulation a lot less accurate.
</p>

<p>
Some MSX machines like the Panasonic FS-A1GT have built in software (called firmware), that can be switched on and off via a switch on the machine itself. In openMSX the internal software is switched off by default, but you can switch it on with the following setting: <code>set firmwareswitch on</code>.
</p>

<p>
If you're not really interested in how long a real MSX would take for loading from diskette or cassette, you could enable the full speed when loading feature: <code>set fullspeedwhenloading on</code>. It runs openMSX at maximum speed whenever it thinks that the MSX is loading. The drawbacks: it might detect a bit too late that the MSX isn't loading anymore, so sometimes the first notes of music played right after loading might be too fast. Also, when loading openMSX will use all CPU power it can get to get the maximum speed.
</p>

<p>
You can save all your current settings with the <code>save_settings</code> command. If you specify a file name after this command, the settings will not be saved to the default settings file (<code>share/settings.xml</code>), but to the specified file. At start up, alternative settings files can be loaded by using the <code>-setting</code> command line option. You can also use the <code>load_settings</code> command to load settings at run time. Settings that are not mentioned in the saved settings file that you are loading will be untouched. If you want openMSX to automatically save your settings when it exits, issue the following setting: <code>set save_settings_on_exit true</code>.
</p>

<h3><a id="plug">3.4 Plug</a></h3>

<p>
The console command <code>plug</code> can be used to plug the so called pluggables (devices) into connectors on the MSX. Examples of connectors are the joystick ports, the printer port, the MIDI in and out connector, the cassette port, etc. Examples of pluggables are joysticks and mice (see below), but also printers and MIDI equipment. The command <code>plug</code> without any parameters will show a list of connectors and what pluggables are plugged into them. Using <code>plug [connector]</code> will only show what is plugged into [connector]. You will not be surprised that the command <code>plug [connector] [pluggable]</code> will plug the [pluggable] into the [connector].
</p>

<p>
Note that using the "tab completion" feature can help you a lot in getting an idea of what plug commands are possible, as it will only complete possible connectors and their possible pluggables. Also just try this.
</p>

<!--
<p class="todo">
Add the complete list of pluggables here.
</p>
-->

<h3><a id="trainer">3.5 Game Trainer</a></h3>

<p>
openMSX 0.6.2 comes with a completely reworked game trainer system. Although it has to be used from the console, it is very easy to use. As always, you could type: <code>help trainer</code>, for some basic help.
</p>

<p>
Suppose you want to cheat on Metal Gear. Then it would be useful to type: <code>trainer Metal[TAB]</code>, which will expand to: <code>trainer Metal\ Gear</code>. When you then press enter, you see which cheats are available in the Metal Gear trainer. You can active them by typing e.g.: <code>trainer Metal\ Gear 1 2 3 4</code>. This will activate (toggle) the first 4 cheats (as the list will tell you which is printed after the command: the crosses mean an active cheat). You can also use the descriptions instead of the numbers: <code>trainer Metal\ Gear "enemy 1 gone" "enemy 2 gone"</code>. Or, if you want to activate all cheats, as was default in the old cheat system, you could simply type: <code>trainer Metal\ Gear all</code>.
</p>

<p>
If this sounds a bit difficult for you, just try it out. It's really much easier when you actually work with it.
As always in the console, using TAB to complete your commands and their options proves to be very useful!
</p>

<h2><a id="media">4. Running MSX Software and Using Media</a></h2>

<p>
With this information, you can run most of the existing MSX software.
</p>

<h3><a id="roms">4.1 Running ROM software</a></h3>

<p>
Suppose you want to run the ROM file <code>galious.rom</code>. Then you simply type:
</p>
<div class="commandline">openmsx galious.rom</div>
<p>
and the emulated MSX will run the game. (Of course,
in this case, the file <code>galious.rom</code> should be in the current directory or in one
of the user directories you specified with the <code>user_directories</code> setting, see the <a class="external" href="setup.html">Setup Guide</a>.)
</p>

<p>
You can also explicitly indicate that the thing is a ROM image like this:
</p>
<div class="commandline">openmsx -cart galious.gam</div>
<p>
This lets openMSX know that the file <code>galious.gam</code> is a ROM cartridge and that openMSX should insert it in the first available free cartridge slot. You can also use <code>-carta</code> to explicitly specify cartridge slot A.
</p>
<p>
Or, maybe openMSX didn't have the ROM in the ROM database and failed auto detection of the mapper type. You can specify the mapper to <code>Konami</code> (formerly known as <code>KONAMI4</code>) like this:
</p>
<div class="commandline">openmsx galious.rom -romtype Konami</div>
<p>
Note that in practice you won't need this, because most ROM images are in the database or auto detected if they are not. The <code>-romtype</code> option should follow the ROM it applies to immediately on the command line.
</p>

<p>
If wanted, openMSX can apply IPS patches to ROM software before running it. IPS patches are files that describe a modification of the ROM you are applying it to, e.g. a translation or a cheat. This way you do not need to alter any files. To apply an IPS patch you have to provide the IPS filename like this:
</p>
<div class="commandline">openmsx -cart galious.rom -ips galiouspatch.ips</div>
<p>
As with the <code>-romtype</code> option, the <code>-ips</code> option on the command line must follow the ROM file it applies to directly. You can also use multiple <code>-ips</code> options if you want to apply multiple patches.
</p>

<p>
If you already have openMSX running and want to insert cartridges at run time (maybe even when the MSX is powered on), you can use the <code>carta</code> command in the console as well, which is just as powerful.
</p>

<h3><a id="disks">4.2 Running Disk Software</a></h3>

<h4><a id="diskimages">4.2.1 Using Disk Images</a></h4>

<p>
To run a disk image, you can type:
</p>
<div class="commandline">openmsx relax.dsk</div>
<p>
for example. Or, if you use a disk image with an extension that is unknown to openMSX:
</p>
<div class="commandline">openmsx -diska relax.di</div>

<p>
You can also change disks at run time of course. Just type
</p>
<div class="commandline">
    diska &lt;diskimage&gt;
</div>
<p>
in the console to put the specified disk image in drive A. To eject the disk from drive A, use:
</p>
<div class="commandline">
    diska -eject
</div>
<p>
Note that inserting another disk image automatically ejects the previous one.
</p>

<p>
Disk images in XSA format are also supported, use them as regular disk images, but do note that they are read only. The same counts for (g)zipped disk images. Note that in zipped disk images the first file that is packed into the zip file will be used as disk image.
</p>

<p>
If wanted, openMSX can also apply IPS patches to disk software before running it. This way you do not need to alter any files. To apply an IPS patch you have to provide the IPS filename like this:
</p>
<div class="commandline">openmsx SDSNAT1C.DSK -ips sdsnat1-eng.ips</div>
<p>
The <code>-ips</code> option must follow directly the disk image on the command line it applies to. You can also use multiple <code>-ips</code> options if you want to apply multiple patches.
</p>

<p>
You can also apply the patches when changing disks at run time. Just type something like
</p>
<div class="commandline">
    diska SDSNAT1C.DSK sdsnat1-eng.ips sd-cheat.ips
</div>
<p>
in the console to put the specified disk image SDSNAT1C.DSK in drive A, with both IPS patches applied.
</p>

<h4><a id="dirasdisk">4.2.2 Using Directories as Disks</a></h4>

<p>
The DirAsDsk feature permits you to use a directory on your host computer's
file system as a disk image for your emulated MSX.  Note that this has nothing
to do with harddisk emulation. It simply creates a
virtual disk structure in memory from the files that are in the directory
that you specified as if it were a disk image. So: </p>
<div class="commandline">
    openmsx -diska .
</div>
<p>
will try to put all files of the current directory on a disk image in memory and
start openMSX with it. The actual data is still read from/written to the files
in your directory so that if you change the content of the files, these changes
are immediately visible to the emulated MSX.  This way you can for instance
edit source files with your favourite text editor but compile them immediately in
the emulated MSX.
</p>
<p>
Adding files on the host OS doesn't have any effect on the disk in openMSX and
vice versa.
</p>
<p>
<em>Be careful when writing to files from your emulated MSX.</em><br/>
If you save an existing file on that disk in the emulated MSX (without
increasing the file size), the change is also reflected on the directory on the
host OS! If the files are bigger than the original size then the extra data
sectors needed will be stored in a hidden sector cache and the extra data will
not be reflected in the host OS files! When stopping the emulator, or
ejecting the fake disk, this sector cache is written in the same directory as
the original files, so that it can be loaded again when restarting the emulator.
So if you use the DirAsDsk feature on a real floppy disk, chances are that
you'll end up with a full disk when this cache is written!
</p>
<p>
Note that this feature is willfully kept very bare bones: it
doesn't support sub directories and it skips all remaining files if the virtual
disk is full. Its main purpose is to facilitate cross platform development.
</p>
<p>
As of openMSX 0.5.2, there is extra functionality to perform file
imports and exports, with support for harddisk images with partitions and normal
disk images. Please see the separate documentation for this in the
<code>doc/Using-diskmanipulator.txt</code> text file.
</p>

<h4><a id="realdisks">4.2.3 Using Real Disks</a></h4>

<p>
To use a real disk, just specify <code>/dev/fd0</code> as a disk image. This is of
course a Linux (Unix, actually) specific feature, but for now it is usable. It
may be a bit slow though, with the FDC emulation enabled. It should be just as
slow as a real disk drive, however! Don't forget that you shouldn't have it
mounted to be able to use it this way. We recommend to use only write-protected
disks! It is possible that you damage the contents of your disk if you don't.
Windows users can try real disks by using the DirAsDsk feature. Because his
feature is still experimental, one should always use it with write protected
disks. Only regular disks with normal files will work with it; specify A: as
disk image to use it.
</p>


<h4><a id="harddisks">4.2.4 Emulating MSX Harddisks and CD-ROM</a></h4>

<p>
openMSX only supports the emulation of the Sunrise IDE interface at the moment.
The extension for this is called 'ide'. The extension has a built in harddisk
configuration, in the form of a 100MB sized disk image. This is the default size: if the harddisk image is
not present, the file is created with this size. The image will end up in your openMSX user directory<code>/persistent/ide/untitled1/hd.dsk</code>.
</p>

<p>
As of openMSX 0.6.1, you can specify the harddisk image to be used on the command line:
</p>
<div class="commandline">openmsx -ext ide -hda symbos.dsk</div>
<p>
This means that you're using the ide extension with symbos.dsk as harddisk image. You can also change the harddisk image at run time in the console (only when the MSX is powered off via the <code>power</code> setting). This works the same as the <code>diska</code> command:
</p>
<div class="commandline">
    hda &lt;diskimage&gt;
</div>

<p>
The 'ide' extension needs the BIOS that can be flashed into the Sunrise IDE
interface. It can be downloaded from the <a class="external"
href="http://www.msx.ch/sunformsx/download/dl-ide.html">Sunrise for MSX web
site</a>.
</p>

<p>
When using this extension for the first time, one has to consider it as using a
real Sunrise IDE interface with a 100MB empty harddisk connected to the master
slot. How to proceed is written in the text files that come with the FDISK
program for IDE, downloadable from the <a class="external"
href="http://www.msx.ch/sunformsx/download/dl-ide.html">Sunrise for MSX web
site</a>. There are also <a class="external"
href="http://www.msx.org/forumtopic6184.html">some</a> <a class="external"
href="http://www.msx.org/forumtopic3015p15.html">threads</a> on the MSX Resource
Center forum that may give you valuable hints.
</p>
<p>
You can side step these procedures by using the <code>diskmanipulator</code> to
create the initial hd image, and you can immediately put some files and
subdirectories on it. For instance to create a hard disk with 3 partitions of
32 megabyte on it, and have each partition filled with files and subdirectories
you can do the following:
</p>
<p>
Start openMSX with the ide extension, then type in the console:
</p>
<div class="commandline">
set power off<br/>
diskmanipulator create /tmp/new-hd.dsk 32M 32M 32M<br/>
hda /tmp/new-hd.dsk<br/>
diskmanipulator import hda1 /home/david/msxdostools/<br/>
diskmanipulator import hda2 /home/david/msxdemos/<br/>
diskmanipulator import hda3 /home/david/msxdrawings/<br/>
set power on
</div>
<p>
For clarity: because the emulation is done on a big disk image, there can be no data corruption of your PC's harddisk. This does mean that you need free
disk space for this image, which can be quite big (default 100MB). So, in other words,  you
can't really use your normal PC harddisk as an MSX harddisk for this extension.
(Maybe on UNIX systems it works if you choose a device like
<code>/dev/hdb</code> as harddisk image file, but we have not tested it and do
note that it can cause loss of data of that partition or disk!)
</p>

<p>
If you still want to use files from your real PC harddisk on the emulated MSX,
you have to use the DirAsDsk feature. See the <a class="internal"
href="#dirasdisk">DirAsDsk section</a> for more details.
</p>

<p>
Last but not least: as of openMSX 0.6.1, there is (limited) support for CD-ROM with the 'ide' extension. The default configuration has a CD-ROM player on the slave port of the IDE interface. You can insert an ISO image in that virtual CD-ROM player with the <code>-cda</code> command line option and change it at run time with the <code>cda</code> console command, all similar to the aforementioned <code>hda</code> and <code>diska</code> commands and options.
</p>

<h3><a id="tape">4.3 Running Tape Software</a></h3>
<h4><a id="tapewav">4.3.1 Using WAV files</a></h4>

<p>
openMSX supports WAV files for tape emulation! Just use an MSX with a
cassette port (at least any MSX1 or MSX2 machine will do) and it should be available.
</p>
<p>
Then type in the console:
</p>
<div class="commandline">
     cassetteplayer insert &lt;file&gt;.wav
</div>
<p>
And then in MSX Basic, type:
</p>
<div class="commandline">
     run"cas:"
</div>
<p>
(or another command to load the program on 'tape'.)
</p>

<p>
Note that in Linux, one should not use the special file <code>/dev/pcm</code> for tape input. openMSX will try to read the file until the end, which doesn't exist.
</p>

<p>
Other cassetteplayer related commands/settings you need to know of are:
</p>
<ul>
	<li><code>cassetteplayer rewind</code>, to rewind the tape</li>
	<li><code>cassetteplayer eject</code>, to eject the tape</li>
	<li><code>cassetteplayer new &lt;filename&gt;</code>, to create a new WAV cassette image to record to; also sets the cassette player in record mode</li>
	<li><code>cassetteplayer play</code>, to set the cassette player in play mode (when you've just recorded to the cassette)</li>
	<li><code>cassetteplayer record</code>, to set the cassette player in record mode, to append to existing cassette images (NOT IMPLEMENTED YET)</li>
	<li><code>set cassetteplayer_volume</code>, to set the volume of the cassette player sound (yeah, the screeching tape sounds!)</li>
</ul>

<h4><a id="cas">4.3.2 Using CAS files</a></h4>
<p>
You can also use the so-called CAS files. Use them exactly as you would use WAV files, described in the previous section.
</p>

<p>
We don't support using CAS files anymore by patching a BIOS, because it is not really something we want: we prefer a more authentic emulation without hacks like this.
So, nowadays, the CAS files are automatically
converted to WAV files, internally. Note that the loading time is drastically
longer this way (but: doing a <code>set fullspeedwhenloading on</code> will help a lot). On the other hand, you will be able to hear the cassette
sounds now also with the CAS files... What is using cassettes with an MSX
without those characteristic sounds?
</p>

<p>
To make it even more comfortable to run software from CAS images, try the following experimental setting, that will attempt to type the loading instruction for you after the MSX has started up:
</p>
<div class="commandline">
     set autoruncassettes on
</div>

<p>
Note that saving to CAS files (new or existing ones) is not possible; one can only save to new cassette images in WAV format.
</p>

<h4><a id="tapejack">4.3.3 Using Jack audio connection kit</a></h4>

<p>
Using <a class="external"
href="http://jackit.sourceforge.net/">Jack</a> is not the easiest
option for running a tape-program, but it is an alternative way in which
openMSX supports saving to cassette. We are planning to use it for other
purposes as well later. This feature is not available on Windows operating
systems.
</p>

<p>
To be able to connect the openMSX cassetteport to other applications
via Jack you will need:
</p>
<ul>
<li>an openMSX build compiled with Jack-support</li>
<li>an MSX hardware configuration with a cassette port (see above)</li>
<li>a running Jack daemon</li>
</ul>

<p>
Type the following in the console to make the cassette port available
to Jack:
</p>
<div class="commandline">
    plug cassetteport cassettejack
</div>

<p>
Now you need to start an external program to make actual
connections. e.g.
</p>
<div class="commandline">
    qjackctl
</div>

<p>
The Jack-pluggable has been successfully tested with
<code>timemachine</code> as recorder and <code>jack.play</code> as
player. More convenient setups may become available as Jack is still
being developed.
</p>
<p>
Note that openMSX can be compiled without Jack-support, use the normal cassetteplayer functions to save to tape in that case.
</p>

<h2><a id="input">5. Input Devices</a></h2>

<h3><a id="keymapping">5.1 Key Mapping</a></h3>

<p>
The next subsections list the default key mapping of openMSX. The mapping of the special MSX keys is hardcoded, but the mapping of the keys for emulator functions is fully customizable using the <code>bind</code> command in the console. Your customized key bindings are saved together with the settings.
</p>

<h4><a id="keymappingpc">5.1.1 Key Mapping on PC</a></h4>
<p>
On PCs (running Windows, Linux or BSD), the special MSX keys are mapped as follows:
</p>

<table>
  <tr> <td>L-CTRL</td> <td>MSX CTRL key</td> </tr>
  <tr> <td>R-CTRL</td> <td>MSX dead (accents) key</td> </tr>
  <tr> <td>L-ALT</td> <td>MSX GRAPH key</td> </tr>
  <tr> <td>R-ALT</td> <td>MSX CODE/KANA key</td> </tr>
  <tr> <td>L-Windows</td> <td>MSX iee ('no') key</td> </tr>
  <tr> <td>R-Windows</td> <td>MSX hai ('yes') key</td> </tr>
  <tr> <td>F7</td> <td>MSX SELECT key</td> </tr>
  <tr> <td>F8</td> <td>MSX STOP key</td> </tr>
</table>

<p>
Several emulator functions are available under keys as well:
</p>

<table>
  <tr> <td>Pause</td> <td>Pause emulation</td> </tr>
  <tr> <td>ALT+F4</td> <td>Quit openMSX</td> </tr>
  <tr> <td>CTRL+Pause (Break)</td> <td>Quit openMSX (not in Windows)</td> </tr>
  <tr> <td>PrtScr</td> <td>Save current screen to a file (screen shot)</td> </tr>
  <tr> <td>F9</td> <td>Toggle full throttle (maximum speed)</td> </tr>
  <tr> <td>F10</td> <td>Toggle console display</td> </tr>
  <tr> <td>F11</td> <td>Toggle audio mute</td> </tr>
  <tr> <td>F12 or ALT+Enter</td> <td>Toggle full screen mode</td> </tr>
</table>
<!--
<p class="todo">
Make the table look better by using cellpadding stuff in the css.
</p>-->

<h4><a id="keymappingmac">5.1.2 Key Mapping on Mac OS X</a></h4>
<p>
On Apple Macintosh computers, the special MSX keys are mapped as follows:
</p>

<table>
  <tr> <td>L-CTRL</td> <td>MSX CTRL key</td> </tr>
  <tr> <td>R-CTRL</td> <td>MSX dead (accents) key</td> </tr>
  <tr> <td>L-ALT</td> <td>MSX GRAPH key</td> </tr>
  <tr> <td>R-ALT</td> <td>MSX CODE/KANA key</td> </tr>
  <tr> <td>F7</td> <td>MSX SELECT key</td> </tr>
  <tr> <td>F8</td> <td>MSX STOP key</td> </tr>
</table>

<p>
Several emulator functions are available under keys as well:
</p>

<table>
  <tr> <td>Cmd+P</td> <td>Pause emulation</td> </tr>
  <tr> <td>Cmd+Q</td> <td>Quit openMSX</td> </tr>
  <tr> <td>Cmd+D</td> <td>Save current screen to a file (screen shot)</td> </tr>
  <tr> <td>Cmd+T</td> <td>Toggle full throttle (maximum speed)</td> </tr>
  <tr> <td>Cmd+L</td> <td>Toggle console display</td> </tr>
  <tr> <td>Cmd+U</td> <td>Toggle audio mute</td> </tr>
  <tr> <td>Cmd+F</td> <td>Toggle full screen mode</td> </tr>
</table>

<p>
Note: if you want to bind your custom keys on the console, use <code>META</code> as a modifier for the Command (Apple logo) key.
</p>

<h3><a id="joystick">5.2 Joystick</a></h3>

<p>If you have a joystick connected to your PC, use the following command to connect it to the emulated MSX:
</p>
<div class="commandline">
    plug joyporta joystick1
</div>

<p>
To connect a fake joystick (emulated with the arrow keys), you can use this <code>plug</code> command:
</p>
<div class="commandline">
    plug joyporta keyjoystick1
</div>
<p>
will connect a fake joystick to joystick port A. Button A of the joystick is mapped to the space bar and Button B to M, when using the default configuration. There are two keyjoysticks, 1 and 2. If you like, you can change the bindings in the console and save the settings as usual. Examples: <code>set keyjoystick2.triga LCTRL</code> or <code>set keyjoystick1.up KP8</code>.
</p>
<p>
Most modern joysticks have more buttons then the 2 buttons that are allowed by the MSX standard. Therefore a lot of games uses extra keys on the keyboard for extra functionality. for instance, all most all Konami games use F1 to pause the game. You can assign these extra functionality to your joystick by using the <code>bind</code> command. As an example here is how to map button 4 of the first joystick to the F1-key, button 5 to F2,...
</p>
<div class="commandline">
  bind "joy1 button4 down" "keymatrixdown 6 0x20"<br/>
  bind "joy1 button4 up" "keymatrixup 6 0x20"<br/>
  bind "joy1 button5 down" "keymatrixdown 6 0x40"<br/>
  bind "joy1 button5 up" "keymatrixup 6 0x40"<br/>
  bind "joy1 button6 down" "keymatrixdown 6 0x80"<br/>
  bind "joy1 button6 up" "keymatrixup 6 0x80"<br/>
  bind "joy1 button7 down" "keymatrixdown 7 0x01"<br/>
  bind "joy1 button7 up" "keymatrixup 7 0x01"<br/>
  bind "joy1 button8 down" "keymatrixdown 7 0x02"<br/>
  bind "joy1 button8 up" "keymatrixup 7 0x02"<br/>
</div>
<p>
For a more detailed explanation of this command see the commands.txt file.
</p>
<h3><a id="mouse">5.3 Mouse</a></h3>

<p>
To connect a mouse, you can also use the <code>plug</code> command:
</p>
<div class="commandline">
    plug joyporta mouse
</div>
<p>
will connect a mouse to joystick port A. If you want the joystick emulation feature that some mice (like the Philips SBC-3810 and the Sony MOS-1) have, keep the left mouse key pressed when plugging it in, just as on a real MSX.
</p>

<p>
If you are using openMSX in windowed mode, it might be tricky to use the mouse. For that you may want to use the following setting: <code>set grabinput on</code>. This makes sure all input goes to openMSX. Your cursor cannot leave the openMSX window with this setting. Just turn it back to off, if you want to disable this again. If you only want to escape the window briefly, use this command: <code>escape_grab</code>. It permits you to leave the window, but the next time you enter it, the cursor is grabbed again. It might be a good idea to bind this command to a key, using the <code>bind</code> command, which is mentioned above.
</p>

<h2><a id="video">6. Video</a></h2>

<h3><a id="renderers">6.1 Renderers</a></h3>

<p>
A renderer is a part of the emulator that generates the graphical part of the emulation: the MSX 'screen'. At the moment, there are three working renderers:
</p>

<dl>

<dt>SDL</dt>
<dd>
This is the default renderer. This renderer is not using any hardware acceleration and has a steady CPU time consumption. The CPU load can be quite high though. It is about 50% on Manuel's Athlon XP 1600+, when emulating a 3.5MHz MSX and using no special graphical effects (see below). The CPU load is smaller if you use a 16 bit per pixel video mode or when you have a CPU with MMX and/or MMXext extensions.
</dd>

<dt>SDLGL</dt>
<dd>
This renderer uses the OpenGL graphics library to optimise the rendering.
Because part of the rendering is done by the graphics hardware,
the CPU load can vary a lot.
The SDLGL renderer is only useful if you have a hardware accelerated
OpenGL library; a software GL implementation will be very slow.
See the Setup Guide for
<a class="external" href="setup.html#opengl">OpenGL performance tips</a>.
Not everything is supported on this renderer, though. It is likely that it will disappear in the future.
</dd>

<dt>SDLGL-PP</dt>
<dd>
This renderer (new as of openMSX 0.6.1) uses the OpenGL graphics library for all post processing (hence the PP), which includes scalers and other effects.
Because part of the rendering is done by the graphics hardware,
the CPU load can vary a lot.
As with SDLGL, the SDLGL-PP renderer is only useful if you have a hardware accelerated
OpenGL library; a software GL implementation will be very slow.
See the Setup Guide for
<a class="external" href="setup.html#opengl">OpenGL performance tips</a>.
If your card supports it, we recommend to use this renderer.
</dd>


</dl>

<p>
You can set the renderer with the <code>renderer</code> setting. You can set full screen mode with the <code>fullscreen</code> setting. Again, to make these settings permanent, use the <code>save_settings</code> command to save them.
</p>

<p>
Note that openMSX can be compiled without the SDLGL and SDLGL-PP renderer; if that is true for the build you're using, you will not be able to switch to the SDLGL and SDLGL-PP renderer. In case your graphics card or driver doesn't support OpenGL framebuffer objects (or if you have an outdated GLEW library), switching to SDLGL-PP may abort openMSX.
</p>

<h3><a id="accuracy">6.2 Accuracy</a></h3>

<p>
The <code>accuracy</code> setting controls how often the renderer is synchronised with the MSX video processor (VDP).
There are three options:
</p>

<dl>
<dt>screen</dt>
<dd>
Synchronise once per screen (frame).
Good enough for most MSX1 software, but will break most raster effects.
</dd>

<dt>line</dt>
<dd>
Synchronise at the start of a line.
This is good enough for most software.
This setting hides imperfections in raster effects,
which could be considered a useful feature.
</dd>

<dt>pixel</dt>
<dd>
Synchronise at the exact pixel where a change occurs.
This is the most realistic setting and therefore set as the default.
To see demos like Unknown Reality (scope part) and Verti correctly,
you should use this setting.
Also, you will see any imperfections in raster effects
just like they occur on a real MSX.
</dd>

</dl>

<h3><a id="scalers">6.3 Scalers</a></h3>

<p>
Most MSX screen modes are only 256&times;212 pixels big. This is quite small for PC screen resolutions of today. That's why you have the possibility to scale up the image. Normally, there are three possible scaling factors: 1, 2 and 3. If you select 1, all MSX pixels are mapped to a 320&times;240 pixels PC window, for 2 to a 640&times;480 pixels window and for 3 to a (surprise!) 960&times;720 window. The setting which determines this is called <code>scale_factor</code>. In general, the higher the factor, the better the output image is; the downside: it takes a lot more CPU processing power.
</p>

<p>Use <code>scale_factor</code> 1 only if you have a slow computer to run openMSX on, because it is very limited in possibilities and in the case of MSX screen modes with more pixels than 256&times;212, you even lose pixels! In that case, the pixels are interpolated. However, when using it full screen, the low resolution is not a problem, especially because most MSX software uses a 256&times;212 mode.
</p>

<p>There is also a number of scaling algorithms (setting <code>scale_algorithm</code>) that can be set. The scaling algorithm determines how exactly the mapping is done between the MSX input screen and the PC output screen. Especially for scaling factors bigger than 1, this allows for extra possibilities in the algorithms, like deinterlacing and adding scanlines, blur, anti-aliasing (rounding of blocky patters like stair cases) or even a Trinitron-like TV effect. When the factor is set to 1, you always get the <code>simple</code> algorithm, see below.
</p>

<p>
An exception to all of this is the SDLGL-PP renderer. With this renderer (when using a suitable video card and driver), scaling is done on the graphics card hardware and will not take extra CPU power. This renderer also gives you the possibility to use a <code>scale_factor</code> of 4. The down side is that not all scalers have been implemented for this renderer. See also below.
</p>

<p>
openMSX contains the following scaling algorithms:
</p>

<dl>

<dt>simple</dt>
<dd>
This algorithm simply expands each MSX pixel to a square of (scale_factor)&times;(scale_factor) PC pixels.
This is the default scaler and it is fast.
The image looks blocky, especially diagonal edges, but it does support scanlines and blur for scale factors of 2 and higher. In combination with a scale factor of 1, you get what was
previously the SDLLo renderer, which is the fastest scaling method available.
</dd>

<dt><a class="external" href="http://scale2x.sourceforge.net/">ScaleNx</a></dt>
<dd>
This scaler algorithm smoothes edges by using only original colours, so it will not give any blur. It is fast and its image is less blocky than that of the simple scaler. However, all corners are rounded, which does not look good on all graphics. This scaler has not been properly implemented for scaling factors of 4.
</dd>


<dt><a class="external" href="http://elektron.its.tudelft.nl/~dalikifa/">SaI</a></dt>
<dd>
This scaler algorithm smoothes edges by interpolating neighbouring pixels.
It is heaver on the CPU than the simple and ScaleNx algorithms.
It does a good job on most graphics, except for high-contrast edges;
for example white fonts on a black background get some nasty gray lines around them.
Also corners are rounded, similar to ScaleNx. This scaler is not available in the SDLGL-PP renderer.
</dd>

<dt><a class="external" href="http://www.hiend3d.com/">hq</a></dt>
<dd>
This scaler algorithm looks somewhat similar to SaI, but its output is sharper.
This complex algorithm is very heavy on the CPU; use this algorithm only on fast PCs.
It does a good job on most graphics; it avoids excessive blurring and it keeps corners sharp.
On some graphics, it does not identify edges correctly, making those edges blocky instead of smooth.
Especially with high scaling factors, it can give a very smooth looking image.
</dd>

<dt>hqlite</dt>
<dd>
This is a variant of hq: the resulting image is close to hq, but it is
calculated a lot faster. It has a good quality per CPU usage ratio.
</dd>

<dt>RGBTriplet</dt>
<dd>
This algorithm only works when a scaling factor of 3 is used. Also, it only works well for MSX screen modes of 256&times;212, which includes most games. The idea of the algorithm is that each input pixel is mapped on a triplet of pixels which represent the R(ed), G(reen) and B(lue) components of the input pixel. This arrangement of RGB components is also used in the <a class="external" href="http://en.wikipedia.org/wiki/Aperture_grille">Aperture Grille</a> CRT's, also known as Trinitron and the modern TFT screens. You can control the effect with the <code>blur</code> setting. This algorithm also includes scan lines. This scaler is not available in the SDLGL-PP renderer.
</dd>

<dt>TV</dt>
<dd>
This algorithm is trying to emulate the fact that on a CRT brighter pixels look bigger than darker pixels. This scaler is only available in the SDLGL-PP renderer.
</dd>

</dl>

<p>
A small (somewhat outdated) demonstration of some of the algorithms can be found on <a class="external" href="http://openmsx.sourceforge.net">the openMSX web site</a>.
</p>

<h3><a id="gamma">6.4 Gamma Correction</a></h3>

<p>
PC monitors can have different gamma values than MSX monitors.
To compensate for this, openMSX has a gamma correction feature.
It is controlled by the <code>gamma</code> setting.
A value of 1.0 disables gamma correction; a lower value makes the image darker; a higher value makes it brighter.
</p>

<p>
If you want to know what gamma correction really means, read <a class="external" href="http://www.bberger.net/rwb/gamma.html">this page about monitor gamma</a>.
The gamma correction value you can set in openMSX should be the gamma of your PC screen divided by the gamma of the MSX screen.
I measured the gamma of my PC screen (TFT) at 2.0 and the gamma of my MSX monitor at 2.5. That puts the gamma correction at 2.0 / 2.5 = 0.8.
So if I enter that value, the openMSX image will have comparable brightness to the MSX image.
However, 0.8 is not the value I'm actually using: I prefer a brighter image than my MSX monitor, so I chose to use a gamma correction of 1.1.
</p>

<h3><a id="videoeffects">6.5 Special Effects</a></h3>

<p>
openMSX contains a couple of special effects settings that can be applied to the video output:
</p>

<dl>

<dt><code>deinterlace</code></dt>
<dd>
Interlacing is a technique to double the vertical resolution by splitting the image into two frames: the first frame the even lines are displayed, the second frame the odd lines are displayed.
The after glow on a TV and some processes in the human brain combine both frames into a single image. However, this process is not perfect and you can notice flickering, especially on horizontal lines.
The deinterlace feature combines the even and the odd frames into a single output frame, thus eliminating the flicker.
The <code>deinterlace</code> setting controls this feature:
it can be on (enabled) or off (disabled); it is enabled by default. This feature needs a scaling factor of at least 2.
</dd>

<dt><code>scanlines</code></dt>
<dd>
On TV's and MSX monitors, you can see a small black space in between the display lines, especially when using NTSC.
The scanlines feature simulates this by drawing some lines a bit darker.
This feature is disabled when a scaling algorithm other than <code>simple</code> or <code>RGBTriplet</code> is used and needs a scaling factor of at least 2.
</dd>

<dt><code>blur</code></dt>
<dd>
TV's and MSX monitors are less sharp than PC monitors:
neighbouring pixels tend to blur into each other.
The blur feature simulates this by interpolating neighbouring pixels.
The <code>blur</code> settings control this:
0 means no blur (completely sharp), 50 means some blur (like a monitor),
100 means maximum blur (like a TV).
All other values between 0 and 100 are also possible of course.
This feature is disabled when a scaling algorithm other than <code>simple</code> or <code>RGBTriplet</code> is used and needs a scaling factor of at least 2.
</dd>

<dt>after glow (<code>glow</code>)</dt>
<dd>
The after glow feature blends each frame with the frame before it.
This results in moving objects leaving a trail (motion blur).
The <code>glow</code> setting controls the amount of after glow:
0 means no after glow, 100 means maximum after glow.
This feature works only in the <code>SDLGL</code> and <code>SDLGL-PP</code> renderers.
</dd>

<dt><code>noise</code></dt>
<dd>
This setting (new in openMSX 0.6.1) controls the amount of pixel noise on the screen.
The <code>noise</code> setting controls the amount:
0 means no noise, 100 means maximum noise. The value is actually the deviation of the color of the original pixel and non-integer values are also possible.
</dd>


<dt>display deformation (<code>display_deform</code>)</dt>
<dd>
This feature (new in openMSX 0.6.1) makes it possible to change the shape of the MSX screen. There are three possibilities:
 <ul>
  <li><code>normal</code>: no deformation (default)</li>
  <li><code>horizontal_stretch</code>: a horizontal stretch to achieve an aspect ratio of the screen that is closer to a real MSX screen</li>
  <li><code>3d</code>: emulates a 3D view on an arcade cabinet's screen</li>
 </ul>
This feature works only in the <code>SDLGL-PP</code> renderer.
</dd>


</dl>

<h3><a id="gfx9000">6.6 GFX9000/Video source</a></h3>

<p>
openMSX has GFX9000 emulation. Note that it still quite new, so it is not as complete and functional as the video emulation of the classical MSX chips. It is also slower than the classical video chips and it does not work with the SDLGL
renderer. Despite of all this, we thought you might wanted to play around
with it anyway...
</p>

<p>
The real GFX9000 has an external video connector to which you can connect a
second monitor. Because of limits of the SDL library we used to create openMSX,
we cannot have more than one window for openMSX, so we cannot emulate a second
monitor. To see the GFX9000 in action, you need to switch the videosource
setting, which equals to a so-called SCART-switch in the real world: <code>set
videosource GFX9000</code>. If you started openMSX without GFX9000 extension,
this option is not available.
</p>

<p>
To get your normal MSX screen back, you should
type <code>set videosource MSX</code>. If you want to toggle with a hot key
between them, it might be useful to bind a key for it. E.g.: <code>bind F6
cycle videosource</code>.<br/>
<code>cycle</code> is a TCL command that cycles through the options of the setting in the parameter.
</p>

<h3><a id="recording">6.7 Video recording</a></h3>

<p>
A new feature of openMSX 0.6.2 is the video recorder. This enables you to record the audio and video rendered by openMSX to an AVI file. (You can read about the codec in the <a class="external" href="faq.html#codec">FAQ</a>.) When replaying it, it should be perfectly in sync without any hiccups, even if the emulation ran too slow when you recorded it. The output video is in 320&times;240 format. It records the current video source (see previous section) and the sound is recorded with the current <code>frequency</code> setting. If you change this setting during recording, or, more importantly, if the software changes from PAL (50Hz) to NTSC (60Hz) during recording, the video will get out of sync with the audio. Any special effects will not be recorded. Finally, here is how to use it: use <code>record start</code> to record to a default file name (you can use an additional filename parameter if you don't like that). <code>record stop</code> stops recording and <code>record toggle</code> toggles it, as you would expect. If you like, you can use <code>-audioonly</code> (see next chapter) or <code>-videoonly</code> options to record only sound or video.
</p>

<h2><a id="audio">7. Audio</a></h2>

<h3><a id="audiosettings">7.1 Audio Settings</a></h3>

<p>
There is a <code>master_volume</code> setting, which controls the overall output volume of openMSX (it applies to all sound devices). Volume 0 means no sound, volume 100 is maximum.
</p>

<p>
There is also a <code>mute</code> setting, to disable all sound from openMSX at once. It can be on (muted) or off (sound is audible). By default, mute is bound to the F11 key.
</p>

<p>
Each sound device in the MSX you are emulating also has its own volume setting. Volume 0 means no sound, volume 100 is maximum. For example: <code>set "MSX Music_volume" 50</code>.
</p>

<p>
All mono sound devices have an additional mode setting. You can use it to select whether this device should be audible on the left channel ("left"), the right channel ("right") or both channels ("mono"). Example: <code>set PSG_mode left</code>. Any sound device can also be individually muted by setting the channel mode to "off".
</p>

<p>
For Windows users there is the choice to use DirectSound or SDL as an audio
driver. By default, DirectSound is used, because it gives a better quality in
most cases. Change it with the <code>sound_driver</code> setting, if you like.
</p>

<h3><a id="midi">7.2 MIDI</a></h3>

<p>
openMSX supports the MSX-MIDI interface of the MSXturboR GT.
To use this feature, start openMSX with the machine
<code>Panasonic_FS-A1GT</code> and plug in a MIDI device on the console.
For example:
</p>
<div class="commandline">
    plug msx-midi-out midi-out-logger
</div>
<p>
This logs all MIDI commands to a file.
Because there is no timing information logged, this is not very useful yet.
</p>

<p>
It's more interesting to connect MSX-MIDI to an actual PC MIDI device,
such as a MIDI out port or the internal synthesizer of your sound card.
On Linux, you can use the <code>midi-out-logger</code> and set a MIDI
device node, for example <code>/dev/midi</code>, as its output file. This is
done by default. To play with this setting, use <code>set
midi-out-logfilename</code>.  On Windows, real MIDI devices are separate
pluggables.
</p>

<h3><a id="soundlogger">7.3 Recording Audio to File</a></h3>

<p>
openMSX 0.6.2 has an improved way to record audio to a file, without any quality loss.
It enables you to record the sound generated from the emulated MSX perfectly.
Note that recording
sound to the uncompressed WAV format will take a lot of disk space. At 44.1kHz
it will take about 176 kB per second.
</p>

<p>
You can simply start the recording of sound by issuing the command <code>record start -audioonly</code>
(or the old command <code>soundlog start</code>). It will automatically choose a file name and save
it in the <code>soundlogs</code> directory in your personal openMSX folder. You
can also add an extra parameter to specify the filename for the new WAV file.
The other two sub commands that speak for themselves are <code>record stop</code> (<code>soundlog
stop</code>) and <code>record toggle -audioonly</code> (<code>soundlog toggle</code>). The latter is useful if you bind
this command to some hot key.
</p>

<h2><a id="debugdevice">8. Debug Device</a></h2>

<p>
This chapter describes how the debug device, built in openMSX, can be used to
the advantage of an MSX programmer. This is an artificial MSX device
that is connected to an MSX I/O port. It can be used to send debug messages to
the host operating system.
</p>

<p>
Note that openMSX also contains real built in debugging functions, which can be
accessed with the <code>debug</code> command. More information about it is in
the aforementioned <code>commands.txt</code> file. With that debugger you can
read and write all registers and memory of almost all devices that are
supported in openMSX. It also supports break points, watch points and stepping.
</p>


<h3><a id="debugdeviceenable">8.1 Enabling the Debug Device</a></h3>

<p>
The easiest way to enable the debugdevice is to start openMSX with the
debugdevice extension. To do this, simply add <code>-ext debugdevice</code> to the
openMSX command line.
</p>

<p>
Another way to make the device work is to add it to the <code>hardwareconfig.xml</code> from
the machine that is used. If, for example, the device has to be used on the
Philips NMS 8250, the following lines can be added to the <code>hardwareconfig.xml</code>
file in the <code>share/machines/Philips_NMS_8250</code> directory.
</p>
<pre>
  &lt;DebugDevice id="Debug Device"&gt;
    &lt;io base="0x2E" num="2" type="O"/&gt;
    &lt;filename&gt;stdout&lt;/filename&gt;
  &lt;/DebugDevice&gt;
</pre>

<p>
The third line is optional and can specify any filename you
like, including <code>stdout</code>.
</p>


<h3><a id="debugdeviceports">8.2 The Output Ports</a></h3>

<p>
Controlling the device is done from within an MSX program. For this purpose, the
output ports 0x2E and 0x2F are used. The first port is the Mode Set Register. Bytes sent to this port have the following meaning.
</p>
<table>
  <tr> <th>bit(s)</th><th>meaning</th> </tr>
  <tr> <td>7  </td> <td> unused </td> </tr>
  <tr> <td>6  </td> <td> line feed mode (0 = line feed at mode change, 1 no line feed)</td> </tr>
  <tr> <td>4-5</td> <td> output mode (0 = OFF, 1 = single byte, 2 = multi byte)</td> </tr>
  <tr> <td>0-3</td> <td> parameters for mode 1 (see below)</td> </tr>
  <tr> <td>0-1</td> <td> parameters for mode 2 (see below)</td> </tr>
</table>

<p>
When using mode 1, single byte mode, these are the parameters:
</p>
<table>
  <tr> <th>bit(s)</th><th>meaning</th> </tr>
  <tr> <td>0</td> <td>  hexadecimal mode on/off </td> </tr>
  <tr> <td>1</td> <td>  binary mode on/off</td> </tr>
  <tr> <td>2</td> <td>  decimal mode on/off</td> </tr>
  <tr> <td>3</td> <td>  ASCII mode on/off</td> </tr>
</table>

<p>
So, every parameter bit turns an output format on or off and more than one output format can be specified at the same time.
</p>

<p>
The parameters for mode 2 (multi byte mode) are as follows:
</p>
<table>
  <tr> <th>bit(s)</th><th>meaning</th> </tr>
  <tr> <td>0-1</td> <td> mode (0 = hex, 1 = binary, 2 = decimal, 3 = ASCII mode)</td> </tr>
</table>

<h3><a id="debugdevicemode1">8.3 Single Byte Mode</a></h3>

<p>
In mode 1, any write to port 0x2F will result in output. This way, the
programmer can see if a specific address is reached by adding a single <code>OUT</code> to
the code. The output depends on the parameters set with the mode register. Each
bit represents a specific format, and by turning the bits on and off, the
programmer can decide which formats should be used.
</p>

<p>
Here is an example:
</p>
<pre>
LD  A,65
OUT ($2f),A
</pre>

<p>
This will give the following output:
</p>

<pre>41h 01000001b 065 'A' emutime: 36407199578
</pre>
<p>
(when all bits are on, mode register = 0x1F)<br/>
or
</p>
<pre>41h 065 'A' emutime: 36407199578
</pre>
<p>
(when the binary bit is off, mode register = 0x1D)<br/>
or
</p>
<pre>41h emutime: 36407199578
</pre>
<p>
(when only the hexbit is on, mode register = 0x11)<br/>
and so on.
</p>

<p>
The EmuTime part is a special number that keeps track of the openMSX emulation.
The larger this number is, the later the event took place. This is a great way
to get an idea of the timing of things.
</p>
<p>
If the character to print is a special character, like carriage return,
linefeed, beep or tab, the character between the ' ' will be a dot (.) and the
normal character is 'displayed' at the very end of the line, so it won't mess up
the layout of the whole line.
</p>


<h3><a id="debugdevicemode2">8.4 Multi Byte Mode</a></h3>

<p>
In mode 2, writing to 0x2F does not output any text. All bytes written to this
register are stored in a buffer and only when the mode register is set again the
output is shown. Unlike mode 1, the data in this mode is always shown in one
mode only. It's either in hex mode, binary mode, decimal mode or ASCII mode, but
never a combination. Also the EmuTime bit is left out.
</p>

<p>
Here is an example:
</p>
<pre>
LD  A,xx
OUT ($2e),A
LD  A,$41
OUT ($2f),A
OUT ($2f),A
OUT ($2f),A
LD  A,xx
OUT ($2e),A
</pre>
<p>
Only at this last instruction the output appears.
</p>

<p>
If we substitute <code>$20</code> for <code>xx</code>, we get:
</p>
<pre>41h 41h 41h</pre>
<p>
and if we substitute <code>$22</code> for <code>xx</code>, we get:
</p>
<pre>065 065 065</pre>
<p>
The extra zero is added to keep alignment.  Finally, if we want ASCII
output, all we need to do is change <code>xx</code> for <code>$23</code>:
</p>
<pre>AAA</pre>
<p>
In this special case, the space in between the data is left out. Any special
character like carriage return, linefeed, beep or tab will be printed as you would expect.
</p>

<h3><a id="debugdeviceoutput">8.5 Controlling the Output</a></h3>

<p>
The openMSX console can be used to control the output of the device. This is
done by the setting <code>debugoutput</code>. You can set it to any file name or to the special settings <code>stdout</code> and <code>stderr</code>, which lets the output go to these special streams.
</p>

<h2><a id="contact">9. Contact Info</a></h2>

<p>
Because openMSX is still in heavy development, feedback and bug reports are very
welcome!
</p>

<p>
If you encounter problems, you have several options:
</p>

<ol>
<li>
If you're a regular user and want to discuss openMSX and possible problems,
join our <code>openmsx-user</code> mailing list.
More info on the
<a class="external" href="http://sourceforge.net/mail/?group_id=38274">openMSX mailing lists</a>,
including an archive of old messages, can be found at SourceForge.
</li>
<li>
Go to our IRC channel: <code>#openMSX</code> on <code>irc.freenode.net</code>
and ask your question there.
</li>
<li>
If you want to address the openMSX developers directly,
post a message to the <code>openmsx-devel</code> mailing list.
More info on the
<a class="external" href="http://sourceforge.net/mail/?group_id=38274">openMSX mailing lists</a>,
including an archive of old messages, can be found at SourceForge.
</li>
<li>
Use one of the
<a class="external" href="http://sourceforge.net/tracker/?group_id=38274">openMSX trackers</a>
at SourceForge.
At the moment of writing, there are four trackers:
Bugs, Support Requests, Patches and Feature Requests.
</li>
<li>
Post a message on the forum on <a class="external" href="http://www.openmsx.org/">www.openmsx.org</a> or the <a class="external" href="http://sourceforge.net/forum/?group_id=38274">openMSX forums</a> at SourceForge.
</li>
</ol>

<p>
In any case, try to give as much information as possible when you describe your
bug or request.
</p>

<p class="version">
$Id$
</p>

</body>
</html>
