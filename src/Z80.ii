// $Id$

inline void Z80::M1Cycle()
{
	R++;
	currentTime += (1+waitCycles);
}


inline void Z80::executeInstruction(byte opcode)
{
	IFF1 = nextIFF1;
	#ifdef Z80DEBUG
		word start_pc = PC.w-1;
	#endif
	M1Cycle();
	(this->*opcode_main[opcode])();	// currentTime can be raised extra
	#ifdef Z80DEBUG
		printf("%04x : instruction ", start_pc);
		Z80_Dasm(&debugmemory[start_pc], to_print_string, start_pc );
		printf("%s\n", to_print_string );
		printf("      A=%02x F=%02x \n", AF.B.h, AF.B.l);
		printf("      BC=%04x DE=%04x HL=%04x \n", BC.w, DE.w, HL.w);
	#endif
	return;
}


/*
 * Input a byte from given I/O port
 */
inline byte Z80::Z80_In (word port) {
	currentTime += 1;
	byte result = interface->readIO(port, currentTime);
	currentTime += 3;
	return result;
}
/*
 * Output a byte to given I/O port
 */
inline void Z80::Z80_Out (word port,byte value) { 
	currentTime += 1;
	interface->writeIO(port, value, currentTime);
	currentTime += 3;
}
/*
 * Read a byte from given memory location
 */
inline byte Z80::Z80_RDMEM(word address) {
#ifdef Z80DEBUG
	currentTime += 1;
	debugmemory[address] = interface->readMem(address, currentTime);
	currentTime += 2;
	return debugmemory[address];
#else
	currentTime += 1;
	byte result = interface->readMem(address, currentTime);
	currentTime += 2;
	return result;
#endif
}
/*
 * Write a byte to given memory location
 */
inline void Z80::Z80_WRMEM(word address, byte value) {
	currentTime += 1;
	interface->writeMem(address, value, currentTime);
	currentTime += 2;
	// No debugmemory[A] here otherwise self-modifying code could
	// alter the executing code before the disassembled opcode
	// is printed;
}

/*
 * Z80_RDOP() is identical to Z80_RDMEM() except it is used for reading
 * opcodes. In case of system with memory mapped I/O, this function can be
 * used to greatly speed up emulation
 */
inline byte Z80::Z80_RDOP(word A) { return Z80_RDMEM(A); }
/*
 * Z80_RDOP_ARG() is identical to Z80_RDOP() except it is used for reading
 * opcode arguments. This difference can be used to support systems that
 * use different encoding mechanisms for opcodes and opcode arguments
 */
inline byte Z80::Z80_RDOP_ARG(word A) { return Z80_RDOP(A); }
/*
 * Z80_RDSTACK() is identical to Z80_RDMEM() except it is used for reading
 * stack variables. In case of system with memory mapped I/O, this function
 * can be used to slightly speed up emulation
 */
inline byte Z80::Z80_RDSTACK(word A) { return Z80_RDMEM(A); }
/*
 * Z80_WRSTACK() is identical to Z80_WRMEM() except it is used for writing
 * stack variables. In case of system with memory mapped I/O, this function
 * can be used to slightly speed up emulation
 */
inline void Z80::Z80_WRSTACK(word A, byte V) { Z80_WRMEM(A,V); }


inline bool Z80::M_C()  { return AF.B.l&C_FLAG; }
inline bool Z80::M_NC() { return !M_C(); }
inline bool Z80::M_Z()  { return AF.B.l&Z_FLAG; }
inline bool Z80::M_NZ() { return !M_Z(); }
inline bool Z80::M_M()  { return AF.B.l&S_FLAG; }
inline bool Z80::M_P()  { return !M_M(); }
inline bool Z80::M_PE() { return AF.B.l&V_FLAG; }
inline bool Z80::M_PO() { return !M_PE(); }

/* Get next opcode argument and increment program counter */
inline byte Z80::Z80_RDMEM_OPCODE () {
	return Z80_RDOP_ARG(PC.w++);
}
inline word Z80::Z80_RDMEM_WORD (word A) {
	byte low  = Z80_RDMEM(A);
	byte high = Z80_RDMEM(((A)+1)&0xFFFF);
	return low+256*high;
}
inline void Z80::Z80_WRMEM_WORD (word A,word V) {
	Z80_WRMEM (A, V&255);
	Z80_WRMEM (((A)+1)&0xFFFF, V>>8);
}
inline word Z80::Z80_RDMEM_OPCODE_WORD () {
	byte low  = Z80_RDMEM_OPCODE();
	byte high = Z80_RDMEM_OPCODE();
	return low+256*high;
}

inline word Z80::M_XIX() { 
	word result = (IX.w+(offset)Z80_RDMEM_OPCODE())&0xFFFF;
	currentTime += 5;
	return result;
}
inline word Z80::M_XIY() { 
	word result = (IY.w+(offset)Z80_RDMEM_OPCODE())&0xFFFF;
	currentTime += 5;
	return result;
}
inline byte Z80::M_RD_XHL() { return Z80_RDMEM(HL.w); }
inline byte Z80::M_RD_XIX() { return Z80_RDMEM(M_XIX()); }
inline byte Z80::M_RD_XIY() { return Z80_RDMEM(M_XIY()); }
inline void Z80::M_WR_XIX(byte a) { Z80_WRMEM(M_XIX(), a); }
inline void Z80::M_WR_XIY(byte a) { Z80_WRMEM(M_XIY(), a); }


inline void Z80::M_POP(word &Rg) {
	byte low  = Z80_RDSTACK(SP.w++);
	byte high = Z80_RDSTACK(SP.w++);
	Rg = low+256*high;
}
inline void Z80::M_PUSH(word Rg) {
	currentTime++;
	Z80_WRSTACK(--SP.w, Rg>>8);
	Z80_WRSTACK(--SP.w, Rg);
}

inline void Z80::M_CALL(word adrs) {
	M_PUSH(PC.w);
	PC.w = adrs;
}
inline void Z80::M_JR(offset e) {
	PC.w += e;
	currentTime += 5;
}
inline void Z80::M_RET() {
	M_POP(PC.w);
}
inline void Z80::M_JP(word adrs) {
	PC.w = adrs;
}

inline void Z80::M_SET(int Bit, byte &Reg) { 
	Reg |= 1<<Bit;
}
inline void Z80::M_RES(int Bit, byte &Reg) {
	Reg &= ~(1<<Bit);
}
inline void Z80::M_BIT(int Bit, byte Reg) {
	// TODO  not for bit n,(hl)
	//               bit n,(ix+d)      
	AF.B.l = (AF.B.l&C_FLAG) | ZSPXYTable[Reg & (1<<Bit)];
}

inline void Z80::M_AND(byte Reg) {
	AF.B.h &= Reg;
	AF.B.l = ZSPXYTable[AF.B.h]|H_FLAG;
}
inline void Z80::M_OR(byte Reg) {
	AF.B.h |= Reg;
	AF.B.l = ZSPXYTable[AF.B.h];
}
inline void Z80::M_XOR(byte Reg) {
	AF.B.h ^= Reg;
	AF.B.l = ZSPXYTable[AF.B.h];
}

inline void Z80::M_IN(byte &Reg) {
	Reg = Z80_In(BC.w);
	AF.B.l = (AF.B.l&C_FLAG)|ZSPXYTable[Reg];
}

inline void Z80::M_RLCA() {
	AF.B.h = (AF.B.h<<1)|((AF.B.h&0x80)>>7);
	AF.B.l = (AF.B.l&0xC4)|(AF.B.h&C_FLAG);
	AF.B.l |= XYTable[AF.B.h];
}
inline void Z80::M_RRCA() {
	AF.B.l = (AF.B.l&0xC4)|(AF.B.h&C_FLAG);
	AF.B.h = (AF.B.h>>1)|(AF.B.h<<7);
	AF.B.l |= XYTable[AF.B.h];
}
inline void Z80::M_RLA() {
	byte i = AF.B.l&C_FLAG;
	AF.B.l = (AF.B.l&0xC4)|((AF.B.h&0x80)>>7);
	AF.B.h = (AF.B.h<<1)|i;
	AF.B.l |= XYTable[AF.B.h];
}
inline void Z80::M_RRA() {
	byte i = AF.B.l&C_FLAG;
	AF.B.l = (AF.B.l&0xC4)|(AF.B.h&0x01);
	AF.B.h = (AF.B.h>>1)|(i<<7);
	AF.B.l |= XYTable[AF.B.h];
}

inline void Z80::M_RLC(byte &Reg) {
	byte q = Reg>>7;
	Reg = (Reg<<1)|q;
	AF.B.l = ZSPXYTable[Reg]|q;
}
inline void Z80::M_RRC(byte &Reg) {
	byte q = Reg&1;
	Reg = (Reg>>1)|(q<<7);
	AF.B.l = ZSPXYTable[Reg]|q;
}
inline void Z80::M_RL(byte &Reg) {
	byte q = Reg>>7;
	Reg = (Reg<<1)|(AF.B.l&1);
	AF.B.l = ZSPXYTable[Reg]|q;
}
inline void Z80::M_RR(byte &Reg) {
	byte q = Reg&1;
	Reg = (Reg>>1)|(AF.B.l<<7);
	AF.B.l = ZSPXYTable[Reg]|q;
}
inline void Z80::M_SLL(byte &Reg) {
	byte q = Reg>>7;
	Reg = (Reg<<1)|1;
	AF.B.l = ZSPXYTable[Reg]|q;
}
inline void Z80::M_SLA(byte &Reg) {
	byte q = Reg>>7;
	Reg <<= 1;
	AF.B.l = ZSPXYTable[Reg]|q;
}
inline void Z80::M_SRL(byte &Reg) {
	byte q = Reg&1;
	Reg >>= 1;
	AF.B.l = ZSPXYTable[Reg]|q;
}
inline void Z80::M_SRA(byte &Reg) {
	byte q = Reg&1;
	Reg = (Reg>>1)|(Reg&0x80);
	AF.B.l = ZSPXYTable[Reg]|q;
}

inline void Z80::M_INC(byte &Reg) {
	++Reg;
	AF.B.l = (AF.B.l&C_FLAG)|
	         ((Reg==0x80) ? V_FLAG : 0)|
	         (((Reg&0x0f)==0x00) ? H_FLAG : 0)|
	         ZSXYTable[Reg];
}
inline void Z80::M_DEC(byte &Reg) {
	Reg--;
	AF.B.l = (AF.B.l&C_FLAG)|
	         ((Reg==0x7f) ? V_FLAG : 0)|
	         (((Reg&0x0f)==0x0f) ? H_FLAG : 0)|
	         ZSXYTable[Reg]|
	         N_FLAG;
}

inline void Z80::M_ADD(byte Reg) {
	int q = AF.B.h + Reg;
	AF.B.l = ZSXYTable[q&255]|
	         ((q&256)>>8)|
	         ((AF.B.h^q^Reg)&H_FLAG)|
	         (((Reg^AF.B.h^0x80)&(Reg^q)&0x80)>>5);
	AF.B.h = q;
}
inline void Z80::M_ADC(byte Reg) {
	int q = AF.B.h + Reg + (AF.B.l&C_FLAG);
	AF.B.l = ZSXYTable[q&255]|
	         ((q&256)>>8)|
	         ((AF.B.h^q^Reg)&H_FLAG)|
	         (((Reg^AF.B.h^0x80)&(Reg^q)&0x80)>>5);
	AF.B.h = q;
}
inline void Z80::M_SUB(byte Reg) {
	int q = AF.B.h - Reg;
	AF.B.l = ZSXYTable[q&255]|
	         ((q&256)>>8)|
	         N_FLAG|
	         ((AF.B.h^q^Reg)&H_FLAG)|
	         (((Reg^AF.B.h)&(Reg^q)&0x80)>>5);
	AF.B.h = q;
}
inline void Z80::M_SBC(byte Reg) {
	int q = AF.B.h - Reg - (AF.B.l&C_FLAG);
	AF.B.l = ZSXYTable[q&255]|
	         ((q&256)>>8)|
	         N_FLAG|
	         ((AF.B.h^q^Reg)&H_FLAG)|
	         (((Reg^AF.B.h)&(Reg^q)&0x80)>>5);
	AF.B.h = q;
}
inline void Z80::M_CP(byte Reg) {
	int q = AF.B.h - Reg;
	AF.B.l = ZSTable[q&255]|
	         XYTable[Reg]|	// XY from operand, not from result
	         ((q&256)>>8)|
	         N_FLAG|
	         ((AF.B.h^q^Reg)&H_FLAG)|
	         (((Reg^AF.B.h)&(Reg^q)&0x80)>>5);
}

inline void Z80::M_ADDW(word &Reg1, word Reg2) {
	int q = Reg1 + Reg2;
	AF.B.l = (AF.B.l&(S_FLAG|Z_FLAG|V_FLAG))|
	         (((Reg1^q^Reg2)&0x1000)>>8)|
	         ((q>>16)&C_FLAG)|
	         XYTable[(q>>8)&255];
	Reg1 = q;
	currentTime += 7;
}
inline void Z80::M_ADCW(word Reg) {
	int q = HL.w+Reg+(AF.B.l&C_FLAG);
	AF.B.l = (((HL.w^q^Reg)&0x1000)>>8)|
	         ((q>>16)&C_FLAG)|
	         ((q&0x8000)>>8)|
	         ((q&0xffff)?0:Z_FLAG)|
	         (((Reg^HL.w^0x8000)&(Reg^q)&0x8000)>>13)|
	         XYTable[(q>>8)&255];
	HL.w = q;
	currentTime += 7;
}
inline void Z80::M_SBCW(word Reg) {
	int q = HL.w-Reg-(AF.B.l&C_FLAG);
	AF.B.l = (((HL.w^q^Reg)&0x1000)>>8)|
	           ((q>>16)&C_FLAG)|
	           ((q&0x8000)>>8)|
	           ((q&0xffff)?0:Z_FLAG)|
	           (((Reg^HL.w)&(Reg^q)&0x8000)>>13)|
		   XYTable[(q>>8)&255]|
	           N_FLAG;
	HL.w = q;
	currentTime += 7;
}

