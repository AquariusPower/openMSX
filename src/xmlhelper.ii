#ifndef __XMLHELPER_II__
#define __XMLHELPER_II__

#include <sstream>

#define HAVE_EXT_HASH_MAP

#include <xml++.h>

template <class T> XMLHelper<T>::XMLHelper<T>(XMLNode *anode):node(anode),emptyString("")
{
}

template <class T> void XMLHelper<T>::setNode(XMLNode *anode)
{
	node = anode;
}

template <class T> void XMLHelper<T>::checkName(const std::string &name)
{
	std::ostringstream buffer;
	if (node->name()!=name)
	{
		buffer << "Expected <" << name << "> node, ";
		buffer << "got <" << node->name() << ">";
		throw T(buffer);
	}
}

template <class T> bool XMLHelper<T>::justCheckName(const std::string &name)
{
	return (node->name()==name);
}

template <class T> void XMLHelper<T>::checkName(const std::list<std::string> &nameList)
{
	bool found = false;
	std::list<std::string>::const_iterator i = nameList.begin();
	for (; i!=nameList.end(); ++i)
	{
		if (node->name() == *i)
			found = true;
	}
	if (!found)
	{
		std::ostringstream buffer;
		buffer << "Expected ";
		i = nameList.begin();
		bool first = true;
		for (; i!=nameList.end(); ++i)
		{
			if (!first)
				buffer << " or ";
			else
				first = false;
			buffer << "<" << *i << ">";
		}
		throw T(buffer);
	}
}

template <class T> void XMLHelper<T>::checkProperty(const std::string &name)
{
	std::ostringstream buffer;
	if (node->property(name)==0)
	{
		buffer << "Expected mandatory property " << name;
		buffer << " for node <" << node->name() << ">";
		throw T(buffer);
	}
}

template <class T> const std::string &XMLHelper<T>::getProperty(const std::string &name)
{
	if (node->property(name)==0)
	{
		return emptyString;
	}
	return node->property(name)->value();

}

template <class T> const std::string &XMLHelper<T>::getProperty(const std::string &name, const std::string &defaultValue)
{
	if (node->property(name)==0)
	{
		return defaultValue;
	}
	return node->property(name).value();
}

template <class T> void XMLHelper<T>::checkChildrenAtLeast(unsigned int num)
{
	std::ostringstream buffer;
	if (node->children().size()<num)
	{
		buffer << "Expected at least " << num;
		buffer << " child-nodes for node <" << node->name();
		buffer << ">";
		throw T(buffer);
	}
}

template <class T> unsigned int XMLHelper<T>::childrenSize()
{
	// TODO, make this a descent C++ cast
	return (int)node->children().size();
}

template <class T> void XMLHelper<T>::checkContentNode()
{
	std::ostringstream buffer;
	if (node->children().size()!=1)
	{
		buffer << "Missing content node for <";
		buffer << node->name() << ">";
		throw T(buffer);
	}
	XMLNodeList::const_iterator i = node->children().begin();
	if ( ! (*i)->is_content() )
	{
		buffer << "Child node of node <" << node->name();
		buffer << "> is not a content node.";
		throw T(buffer);
	}
}

template <class T> const std::string &XMLHelper<T>::getContent()
{
	XMLNodeList::const_iterator i = node->children().begin();
	return (*i)->content();
}

std::string space(int depth)
	{
		std::ostringstream t;
		if (depth>0)
		{
			for (int i=0;i<depth*4;i++)
				t << " ";
		}
		return t.str();
	}

template <class T> void XMLHelper<T>::dump(int depth=0)
{
	// dump a node, recursivly
	std::cout << space(depth) << "name: " << node->name() << std::endl;
	if (node->children().size()>0)
	{
		XMLNodeList::const_iterator i = node->children().begin();
		for (; i!=node->children().end(); ++i)
		{
			XMLHelper<T> xh(*i);
			xh.dump(depth+1);
		}
	}
}

#endif
