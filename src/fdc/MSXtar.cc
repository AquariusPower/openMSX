// $Id$

#include "MSXtar.hh"
#include "SectorBasedDisk.hh"

namespace openmsx {


// bootblock created with regular nms8250 and '_format'
byte MSXtar::Dos1BootBlock[] =
{
0xeb,0xfe,0x90,0x4e,0x4d,0x53,0x20,0x32,0x2e,0x30,0x50,0x00,0x02,0x02,0x01,0x00,
0x02,0x70,0x00,0xa0,0x05,0xf9,0x03,0x00,0x09,0x00,0x02,0x00,0x00,0x00,0xd0,0xed,
0x53,0x59,0xc0,0x32,0xd0,0xc0,0x36,0x56,0x23,0x36,0xc0,0x31,0x1f,0xf5,0x11,0xab,
0xc0,0x0e,0x0f,0xcd,0x7d,0xf3,0x3c,0xca,0x63,0xc0,0x11,0x00,0x01,0x0e,0x1a,0xcd,
0x7d,0xf3,0x21,0x01,0x00,0x22,0xb9,0xc0,0x21,0x00,0x3f,0x11,0xab,0xc0,0x0e,0x27,
0xcd,0x7d,0xf3,0xc3,0x00,0x01,0x58,0xc0,0xcd,0x00,0x00,0x79,0xe6,0xfe,0xfe,0x02,
0xc2,0x6a,0xc0,0x3a,0xd0,0xc0,0xa7,0xca,0x22,0x40,0x11,0x85,0xc0,0xcd,0x77,0xc0,
0x0e,0x07,0xcd,0x7d,0xf3,0x18,0xb4,0x1a,0xb7,0xc8,0xd5,0x5f,0x0e,0x06,0xcd,0x7d,
0xf3,0xd1,0x13,0x18,0xf2,0x42,0x6f,0x6f,0x74,0x20,0x65,0x72,0x72,0x6f,0x72,0x0d,
0x0a,0x50,0x72,0x65,0x73,0x73,0x20,0x61,0x6e,0x79,0x20,0x6b,0x65,0x79,0x20,0x66,
0x6f,0x72,0x20,0x72,0x65,0x74,0x72,0x79,0x0d,0x0a,0x00,0x00,0x4d,0x53,0x58,0x44,
0x4f,0x53,0x20,0x20,0x53,0x59,0x53,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

// bootblock created with nms8250 and MSX-DOS 2.20
byte MSXtar::Dos2BootBlock[] =
{
0xeb,0xfe,0x90,0x4e,0x4d,0x53,0x20,0x32,0x2e,0x30,0x50,0x00,0x02,0x02,0x01,0x00,
0x02,0x70,0x00,0xa0,0x05,0xf9,0x03,0x00,0x09,0x00,0x02,0x00,0x00,0x00,0x18,0x10,
0x56,0x4f,0x4c,0x5f,0x49,0x44,0x00,0x71,0x60,0x03,0x19,0x00,0x00,0x00,0x00,0x00,
0xd0,0xed,0x53,0x6a,0xc0,0x32,0x72,0xc0,0x36,0x67,0x23,0x36,0xc0,0x31,0x1f,0xf5,
0x11,0xab,0xc0,0x0e,0x0f,0xcd,0x7d,0xf3,0x3c,0x28,0x26,0x11,0x00,0x01,0x0e,0x1a,
0xcd,0x7d,0xf3,0x21,0x01,0x00,0x22,0xb9,0xc0,0x21,0x00,0x3f,0x11,0xab,0xc0,0x0e,
0x27,0xcd,0x7d,0xf3,0xc3,0x00,0x01,0x69,0xc0,0xcd,0x00,0x00,0x79,0xe6,0xfe,0xd6,
0x02,0xf6,0x00,0xca,0x22,0x40,0x11,0x85,0xc0,0x0e,0x09,0xcd,0x7d,0xf3,0x0e,0x07,
0xcd,0x7d,0xf3,0x18,0xb8,0x42,0x6f,0x6f,0x74,0x20,0x65,0x72,0x72,0x6f,0x72,0x0d,
0x0a,0x50,0x72,0x65,0x73,0x73,0x20,0x61,0x6e,0x79,0x20,0x6b,0x65,0x79,0x20,0x66,
0x6f,0x72,0x20,0x72,0x65,0x74,0x72,0x79,0x0d,0x0a,0x24,0x00,0x4d,0x53,0x58,0x44,
0x4f,0x53,0x20,0x20,0x53,0x59,0x53,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

MSXtar::MSXtar(SectorBasedDisk& sectordisk)
{
	disk=&sectordisk;

	nbSectorsPerCluster=2;
	MSXchrootStartIndex=0;
	MSXpartition=0;
	do_extract=false;
	do_subdirs=true;
	do_singlesided=false;
	touch_option=false;
	keep_option=false;
	msxdir_option=false;
	msxpart_option=false;
	msx_allpart=false;
	do_fat16=false;
	DefaultBootBlock=Dos2BootBlock;
}

MSXtar::~MSXtar()
{

}
/* functions to change DirEntries */
/* #define setsh(x,y) {x[0]=y;x[1]=y>>8;} */
void MSXtar::setsh(byte* x,int y) 
{
	x[0]=(byte)(y & 255);
	x[1]=(byte)((y>>8)&255);
}
/* #define setlg(x,y) {x[0]=y;x[1]=y>>8;x[2]=y>>16;x[3]=y>>24;} */
void MSXtar::setlg(byte* x,int y)
{
	x[0]=(byte)(y & 255);
	x[1]=(byte)((y>>8)&255);
	x[2]=(byte)((y>>16)&255);
	x[3]=(byte)((y>>24)&255);
}

/* functions to read DirEntries */
/* #define rdsh(x) (x[0]+(x[1]<<8)) */
word MSXtar::rdsh(byte* x)
{
	return  (x[0]+(x[1]<<8));
}

/* #define rdlg(x) (x[0]+(x[1]<<8)+(x[2]<<16)+(x[3]<<24)) */
int MSXtar::rdlg(byte* x)
{
	return (x[0]+(x[1]<<8)+(x[2]<<16)+(x[3]<<24));
}

/** Transforms a clusternumber towards the first sector of this cluster
  * The calculation uses info read fom the bootsector
  */
int MSXtar::clusterToSector(int cluster)
{
	return 1+RootDirEnd + sectorsPerCluster*( cluster - 2 );
}

/** Transforms a sectornumber towards it containing cluster
  * The calculation uses info read fom the bootsector
  */
word MSXtar::sectorToCluster(int sector)
{
	return 2+(int)((sector-(1+RootDirEnd))/sectorsPerCluster);
}


/** Initialize object variables by reading info from the bootsector
  */
void MSXtar::readBootSector(byte* buf)
{
	struct MSXBootSector *boot=(struct MSXBootSector*)buf;

	nbSectors = rdsh(boot->nrsectors); // asume a DS disk is used
	sectorsPerTrack = rdsh(boot->nrsectors);
	nbSides = rdsh(boot->nrsides);
	nbFats=(byte)boot->nrfats[0];
	sectorsPerFat=rdsh(boot->sectorsfat);
	nbRootDirSectors=rdsh(boot->direntries)/16;
	sectorsPerCluster=(int)(byte)boot->spcluster[0] ;

	RootDirStart=1+nbFats*sectorsPerFat;
	MSXchrootSector=RootDirStart;

	RootDirEnd=RootDirStart+nbRootDirSectors-1;
	maxCluster=sectorToCluster(nbSectors);
	
}

// Create a correct bootsector depending on the required size of the filesystem
void MSXtar::setBootSector(byte* buf, word nbsectors)
{
	// variables set to single sided disk by default
	word nbSides=1;
	byte nbFats=2;
	byte nbReservedSectors=1; // Just copied from a 32MB IDE partition
	byte nbSectorsPerFat=2;
	byte nbHiddenSectors=1;
	word nbDirEntry=112;
	byte descriptor=0xf8;

	// now set correct info according to size of image (in sectors!)
	// and using the same layout as used by Jon in IDEFDISK v 3.1
	if (nbSectors >= 32733 ) {
		nbSides=2;		/*unknow yet */
		nbFats=2;		/*unknow yet */
		nbSectorsPerFat=12;	/*copied from a partition from an IDE HD */
		nbSectorsPerCluster=16;
		nbDirEntry=256;
		nbSides=32;		/*copied from a partition from an IDE HD */
		nbHiddenSectors=16;
		descriptor=0xf0;
	} else if (nbSectors >= 16389 ) {
		nbSides=2;		/*unknow yet */
		nbFats=2;		/*unknow yet */
		nbSectorsPerFat=3;	/*unknow yet */
		nbSectorsPerCluster=8;
		nbDirEntry=256;
		descriptor=0xf0;
	} else if (nbSectors >= 8213 ) {
		nbSides=2;		/*unknow yet */
		nbFats=2;		/*unknow yet */
		nbSectorsPerFat=3;	/*unknow yet */
		nbSectorsPerCluster=4;
		nbDirEntry=256;
		descriptor=0xf0;
	} else if (nbSectors >= 4127 ) {
		nbSides=2;		/*unknow yet */
		nbFats=2;		/*unknow yet */
		nbSectorsPerFat=3;	/*unknow yet */
		nbSectorsPerCluster=2;
		nbDirEntry=256;
		descriptor=0xf0;
	} else if (nbSectors >= 2880 ) {
		nbSides=2;		/*unknow yet */
		nbFats=2;		/*unknow yet */
		nbSectorsPerFat=3;	/*unknow yet */
		nbSectorsPerCluster=1;
		nbDirEntry=224;
		descriptor=0xf0;
	} else if (nbSectors >= 1441 ) {
		nbSides=2;		/*unknow yet */
		nbFats=2;		/*unknow yet */
		nbSectorsPerFat=3;	/*unknow yet */
		nbSectorsPerCluster=2;
		nbDirEntry=112;
		descriptor=0xf0;

	} else if (nbSectors <= 720 ) {
		// normal single sided disk
		nbSectors = 720 ;
	} else {
		// normal double sided disk
		nbSectors = 1440 ;
		nbSides=2;
		nbFats=2;
		nbSectorsPerFat=3;
		nbSectorsPerCluster=2;
		nbDirEntry=112;
		descriptor=0xf9;
	}
	struct MSXBootSector *boot=(struct MSXBootSector *)buf;

	setsh(boot->nrsectors,nbSectors);
	setsh(boot->nrsides,nbSides);
	boot->spcluster[0]=(byte)nbSectorsPerCluster;
	boot->nrfats[0]=nbFats;
	setsh(boot->sectorsfat,nbSectorsPerFat);
	setsh(boot->direntries,nbDirEntry);
	boot->descriptor[0]=descriptor;
	setsh(boot->reservedsectors,nbReservedSectors);
	setsh(boot->hiddensectors,nbHiddenSectors);

}

// Format a diskimage with correct bootsector,FAT etc.
void MSXtar::format()
{
	byte descriptor;
	byte sectorbuf[512];

	// first create a bootsector and start from the default bootblock
	memcpy(sectorbuf, DefaultBootBlock, SECTOR_SIZE);
	setBootSector(sectorbuf,disk->getNbSectors());
	readBootSector(sectorbuf); //set object variables to correct values
	disk->writeLogicalSector(0,sectorbuf);

	{
	struct MSXBootSector *boot=(struct MSXBootSector*)sectorbuf;
	descriptor = boot->descriptor[0];
	}
	// Assign default empty values to disk
	memset( sectorbuf, 0x00, SECTOR_SIZE);
	for (int i=RootDirEnd ; i > 1 ; i--) {
		disk->writeLogicalSector(i,sectorbuf);
	}
	// for some reason the first 3bytes are used to indicate the end of a cluster, making the first available cluster nr 2
	// some sources say that this indicates the disk format and FAT[0]should 0xF7 for single sided disk, and 0xF9 for double sided disks
	// TODO: check this :-)
	// for now I simply repeat the media descriptor here
	sectorbuf[0] = descriptor;
	sectorbuf[1] = 0xFF;
	sectorbuf[2] = 0xFF;
	disk->writeLogicalSector(1,sectorbuf);


	memset( sectorbuf, 0xE5, SECTOR_SIZE);
	for (unsigned int i=1+RootDirEnd; i < disk->getNbSectors() ; i++) {
		disk->writeLogicalSector(i,sectorbuf);
	}


}

} // namespace openmsx

