// $Id$

#include "AbstractIDEDevice.hh"
#include "EventDistributor.hh"
#include "LedEvent.hh"
#include <cassert>
#include <string.h>

namespace openmsx {

static const byte defaultIdentifyBlock[512] = {
	0x5a,0x00,0xba,0x09,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x3f,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
	0x20,0x20,0x20,0x20,0x20,0x20,0x31,0x20,0x00,0x00,0x00,0x01,0x04,0x00,0x31,0x56,
	0x30,0x2e,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
	0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
	0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x10,0x80,
	0x00,0x00,0x00,0x0b,0x00,0x00,0x00,0x02,0x00,0x02,0x03,0x00,0xba,0x09,0x10,0x00,
	0x3f,0x00,0x60,0x4c,0x26,0x00,0x00,0x00,0xe0,0x53,0x26,0x00,0x07,0x00,0x07,0x04,
	0x03,0x00,0x78,0x00,0x78,0x00,0xf0,0x00,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};


AbstractIDEDevice::AbstractIDEDevice(
	EventDistributor& eventDistributor_, const EmuTime& /*time*/
	)
	: eventDistributor(eventDistributor_)
{
	buffer = new byte[512 * 256];

	transferRead = transferWrite = false;
}

AbstractIDEDevice::~AbstractIDEDevice()
{
	delete[] buffer;
}

void AbstractIDEDevice::reset(const EmuTime& /*time*/)
{
	errorReg = 0x01;
	sectorCountReg = 0x01;
	sectorNumReg = 0x01;
	cylinderLowReg = 0x00;
	cylinderHighReg = 0x00;
	devHeadReg = 0x00;
	statusReg = DRDY | DSC;
	featureReg = 0x00;
	setTransferRead(false);
	setTransferWrite(false);
}

byte AbstractIDEDevice::readReg(nibble reg, const EmuTime& /*time*/)
{
	switch (reg) {
	case 1:	// error register
		return errorReg;

	case 2:	// sector count register
		return sectorCountReg;

	case 3:	// sector number register
		return sectorNumReg;

	case 4:	// cyclinder low register
		return cylinderLowReg;

	case 5:	// cyclinder high register
		return cylinderHighReg;

	case 6:	// device/head register
		// DEV bit is handled by IDE interface
		return devHeadReg;

	case 7:	// status register
		return statusReg;

	case 8:
	case 9:
	case 10:
	case 11:
	case 12:
	case 13:
	case 15:// not used
		return 0x7F;

	case 0:	// data register, converted to readData by IDE interface
	case 14:// alternate status reg, converted to read from normal
		// status register by IDE interface
	default:
		assert(false);
		return 0x7F;	// avoid warning
	}
}

void AbstractIDEDevice::writeReg(
	nibble reg, byte value, const EmuTime& /*time*/
	)
{
	switch (reg) {
	case 1: // feature register
		featureReg = value;
		break;

	case 2: // sector count register
		sectorCountReg = value;
		break;

	case 3: // sector number register
		sectorNumReg = value;
		break;

	case 4: // cyclinder low register
		cylinderLowReg = value;
		break;

	case 5: // cyclinder high register
		cylinderHighReg = value;
		break;

	case 6: // device/head register
		// DEV bit is handled by IDE interface
		devHeadReg = value;
		break;

	case 7: // command register
		statusReg &= ~(DRQ | ERR);
		setTransferRead(false);
		setTransferWrite(false);
		executeCommand(value);
		break;

	case 8:
	case 9:
	case 10:
	case 11:
	case 12:
	case 13:
	case 15: // not used
	case 14: // device control register, handled by IDE interface
		// do nothing
		break;

	case 0: // data register, converted to readData by IDE interface
	default:
		assert(false);
		break;
	}
}

word AbstractIDEDevice::readData(const EmuTime& /*time*/)
{
	if (!transferRead) {
		// no read in progress
		return 0x7F7F;
	}
	word result = transferPntr[0] + (transferPntr[1] << 8);
	transferPntr += 2;
	if (--transferCount == 0) {
		// everything read
		setTransferRead(false);
		statusReg &= ~DRQ;
	}
	return result;
}

void AbstractIDEDevice::writeData(word value, const EmuTime& /*time*/)
{
	if (!transferWrite) {
		// no write in progress
		return;
	}
	transferPntr[0] = value & 0xFF;
	transferPntr[1] = value >> 8;
	transferPntr += 2;
	transferCount--;
	if ((transferCount & 255) == 0) {
		writeBlockComplete();
		transferPntr = buffer;
	}
	if (transferCount == 0) {
		// everything written
		setTransferWrite(false);
		statusReg &= ~DRQ;
		writeTransferComplete();
	}
}

void AbstractIDEDevice::writeTransferComplete()
{
}

void AbstractIDEDevice::setError(byte error)
{
	errorReg = error;
	statusReg |= ERR;
	statusReg &= ~DRQ;
	setTransferWrite(false);
	setTransferRead(false);
}

unsigned AbstractIDEDevice::getSectorNumber() const
{
	return sectorNumReg | (cylinderLowReg << 8) |
		(cylinderHighReg << 16) | ((devHeadReg & 0x0F) << 24);
}

unsigned AbstractIDEDevice::getNumSectors() const
{
	return (sectorCountReg == 0) ? 256 : sectorCountReg;
}

void AbstractIDEDevice::executeCommand(byte cmd)
{
	switch (cmd) {
	case 0x91: // Initialize Device Parameters
		// ignore command
		break;

	case 0xEC: { // ATA Identify Device
		memcpy(buffer, defaultIdentifyBlock, 512);
		transferCount = 512 / 2;
		transferPntr = buffer;

		const std::string& name = getDeviceName();
		std::string::const_iterator it = name.begin();
		for (int pos = 0; pos < 20; pos++) {
			char c1, c2;
			if (it == name.end()) { c1 = 0x20; } else { c1 = *it++; }
			if (it == name.end()) { c2 = 0x20; } else { c2 = *it++; }
			buffer[(27 + pos) * 2 + 0] = c2;
			buffer[(27 + pos) * 2 + 1] = c1;
		}

		fillIdentifyBlock();
		setTransferRead(true);
		statusReg |= DRQ;
		break;
	}
	case 0xEF: // Set Features
		switch (featureReg) {
		case 0x03: // Set Transfer Mode
			break;
		default:
			setError(ABORT);
		}
		break;

	default: // unsupported command
		//fprintf(stderr, "IDE command %02X\n", cmd);
		setError(ABORT);
	}
}

void AbstractIDEDevice::startReadTransfer(unsigned count)
{
	transferPntr = buffer;
	transferCount = count;
	statusReg |= DRQ;
	setTransferRead(true);
}

void AbstractIDEDevice::abortReadTransfer(byte error)
{
	setError(error | ABORT);
	setTransferRead(false);
}

void AbstractIDEDevice::startWriteTransfer(unsigned count)
{
	transferPntr = buffer;
	transferCount = count;
	statusReg |= DRQ;
	setTransferWrite(true);
}

void AbstractIDEDevice::abortWriteTransfer(byte error)
{
	setError(error | ABORT);
	setTransferWrite(false);
}

void AbstractIDEDevice::setTransferRead(bool status)
{
	if (status != transferRead) {
		transferRead = status;
		if (!transferWrite) {
			// (this is a bit of a hack!)
			eventDistributor.distributeEvent(
				new LedEvent(LedEvent::FDD, transferRead)
				);
		}
	}
}

void AbstractIDEDevice::setTransferWrite(bool status)
{
	if (status != transferWrite) {
		transferWrite = status;
		if (!transferRead) {
			// (this is a bit of a hack!)
			eventDistributor.distributeEvent(
				new LedEvent(LedEvent::FDD, transferWrite)
				);
		}
	}
}

} // namespace openmsx
