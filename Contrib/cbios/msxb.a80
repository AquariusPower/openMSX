; MSX Compatible BIOS ver 0.05 project "build castles in the air"
; copyright(c) 2002 boukichi
;
; [date]
; 2002/08/07 start...
; 2002/08/09 my birthday!! & playable game!
; 2002/08/13 added font,print infomation
;            key_in routine
; 2002/08/15 improved cartridge recognition.
; 2002/08/19 added DCOMPR(0020h) function.
;            a decrease wait sec.
; 2002/08/20 added a $fcc2-$fcc4 table initializer.(playable zanac) 
;            added a in_joy and in_trig function.
;            divided half. use "set.bat" to rename and merge 32kbyte.
; 2002/08/21 change project name.
; 2002/08/24 added 0072h INITGRP(Screen2) routine,005Fh CHGMOD routine.
;            0090h sound_init function.
; 2002/08/26 added set initial value to GRP???,MLT???
;            rewrited function the recognition of memory. 
;            added routine of the call H.STKE. 
;            fixed many routines.
; 2002/02/27 added sound test mode.

        title "MSX COMPATIBLE BIOS for emulators ver 0.05 by BouKiCHi"

;---------------------------------------------------
; define I/O and Hook
;

PRN_STAT equ $90 ; Printer Status
VDP_RP   equ $98 ; VDP Read Port
VDP_STAT equ $99 ; VDP Status & Latch Reset

PSL_STAT equ $A8 ; Slot status
KBD_STAT equ $A9 ; Keyboard status
GIO_REGS equ $AA ; General IO register
PPI_REGS equ $AB ; PPI register

PSG_REGS equ $A0 ; PSG register number
PSG_DATA equ $A1 ; PSG data
PSG_STAT equ $A2 ; PSG status


MAP_REG1 equ $FC ; Mapper 0000h-3FFFh
MAP_REG2 equ $FD ; Mapper 4000h-7FFFh
MAP_REG3 equ $FE ; Mapper 8000h-BFFFh
MAP_REG4 equ $FF ; Mapper C000h-FFFFh

VDP_DATA equ $98 ; VDP data store
VDP_ADDR equ $99 ; VDP address
VDP_PALT equ $9A ; VDP palette latch
VDP_REGS equ $9B ; VDP register access

H.KEYI   equ $FD9A ; keyboard interrupt hook
H.TIMI   equ $FD9F ; timer interrupt hook
H.NMI    equ $FDD6 ; non maskable interrupt hook
H.STKE   equ $FEDA ; Stack error.


EXP_TBL  equ $FCC1 ; second slot infomation table
SLT_TBL  equ $FCC5 ; table of primary slot

SSL_REGS equ $FFFF ; register of second slot.

;----------------------------------------------
; WORK MEMORY TABLE
GRPNAM   equ $F3C7  ; Screen2 Name
GRPCOL   equ $F3C9  ; Screen2 Color
GRPCGP   equ $F3CB  ; Screen2 CG pattern
GRPATR   equ $F3CD  ; Screen2 Attribute
GRPPAT   equ $F3CF  ; Screen2 Sprite pattern

MLTNAM   equ $F3D2  ; Screen3 Name
MLTCOL   equ $F3D4  ; Screen3 Color
MLTCGP   equ $F3D6  ; Screen3 CG pattern
MLTATR   equ $F3D8  ; Screen3 Attribute
MLTPAT   equ $F3DA  ; Screen3 Sprite pattern

CLIKSW   equ $F3DB  ; Key Click.

STATFL   equ $F3E7
RG0SAV   equ $F3DF
RG1SAV   equ $F3E0

CLIKFL   equ $FBD9
OLDKEY   equ $FBDA 
NEWKEY   equ $FBE5
KEYBUF   equ $FBF0

PUTPNT   equ $F3F8 ; pointer of keybuffer address
GETPNT   equ $F3FA ; pointer of keybuffer address

BOTTOM   equ $FC58
SCRMOD   equ $FCAF

FORCLR   equ $F3E9
BAKCLR   equ $F3EA
BDRCLR   equ $F3EB

PSG_DBG  equ $F3EC ; this is test flag for debug..

CSRY     equ $F3DC ; cursor position(Y axis) 
CSRX     equ $F3DD ; cursor position(X axis) 


;------------------------
;for sound_mode
SMOD_TSTSND equ $F304 ; [byte] store flag of sound test..
SMOD_REQNUM equ $F305 ; [byte] store request number.
SMOD_OLDKEY equ $F306 ; [byte] store oldkey.
SMOD_ROMSUM equ $F307 ; [word] store checksum.
SMOD_MUSLST equ $F309 ; [word] store address of music list.
SMOD_INIT   equ $F30B ; [word] store address of initialization.
SMOD_PLAY   equ $F30D ; [word] store address of play routine.

;-----------------
; memory for the debug-subroutine
;-----------------

DISPADDR equ $E010 ; memory of dumping address.
LASTSTAC equ $E000
SP_REGS  equ $E002 

;---------------------
; Jump Table
;---------------------

; start
Start 
        code
;0000h CHKRAM
chkram
        org     $0000
        di
        jp      soft_reset

        org     $0006

rdvdpa  db      VDP_DATA ; port of Read  VDP
wrvdpa  db      VDP_DATA ; port of Write VDP

;0008h SYNCHR
synchr
        org     $0008
        nop
        ret

;000Ch RDSLT   read memory in any slot. 
        org     $000c
        jp      rdslt
        ret
chrgtb
        org     $0010
        nop
        ret
wrslt
        org     $0014
        nop
        ret
outdo
        org     $0018
        nop
        ret
;001Ch CALSLT Interslot call routine.
calslt
        org     $001c
        jp      cal_slt
        ret

;0020h DCOMPR compare HL,DE
dcompr  org     $0020
        jp      wordcomp
        ret

;0024h ENA_SLT Change of Slot
slot_set org	  $0024
	jp	slt_set

;002D version ID and other.
romid
        org       $002d
; version of MSX
        db 0 ; msx1
stat    db 0 ; ??
stat2   db 0 ; ??

;0030h CALLF Interslot Call routine(RST 30h version)
        org     $0030
        jp      call_lf

;0038h INT_38 interrupt routine (RST38,VBlank,Timer...) 
        org     $0038
        jp      int_start

;0038h INITIO Initialize I/O
        org     $003b
        ret

;0041h DISSCR Disable Screen 
        org     $0041
        jp      disscr
;0044h ENASCR Enable Screen
        org     $0044
        jp      enascr
;---------------
;vdp_routine
;---------------
;0047h WRTVDP
        org 	$0047
        jp	wrt_vdp
;004Ah RDVRM
	org	$004a
	jp	rd_vrm
;004Dh WRTVRM
        org	$004d
        jp      wrt_vrm


;0050h SETRD
        org $0050
        jp vdp_setrd

;0053h SETWRT  .. Set adress for the write VRAM.  
        org $0053
        jp vdp_setwrt

        org $0056
        jp vdp_fillmem
        org $0059
        jp vdp_ldirmv   ; VRAM -> Memory
        org $005C
        jp vdp_data_rep ; Memory -> VRAM

        org $005f
        jp chgmod

;0062h  CHGCLR
       org $0062
       jp  chgclr
        

;0066h INT_NMI .. Non Maskable Interrupt.
        org $0066
        jp nmi_int

;0069h CLRSPR  .. Clear all sprites
        org $0069
        ret

;0072h INITGRP initialize screen to graphics mode.
        org  $0072
        jp   init_grp

;0085h DOLINE Line
doline
        org       $0085
        ret
;0089h GRPPRT basic?
grpprt
        org       $0089
        ret

        org       $008a
        ret
;
;0090h GICINI initialize sound ic
        org     $0090
        jp      sound_init
        org     $0093
        jp      sound_out
        org     $0096
        jp      sound_stat

;009Ch CHSNS  .. check KeyBuffer
        org     $009c
        jp      ch_sns

;00D5h GTSTCK .. Get Joystick position status
        org       $00d5
        jp      in_joy
;00D8h GTTRIG .. Get trigger status
        org       $00d8
        jp      in_trig

;012Dh WRTVDP .. Write VDP register.. 
wrtvdp  org       $012d
        ret

;0131h VDPSTA .. Read VDP status.. 
vdpsta  org       $0131
        ret

;0138h RDSLTREG Read register of primary slot
g_slotreg
        org       $0138
        jp      get_slotreg

;013Bh WRSLTREG Write register of primary slot
s_slotreg
        org       $013B
        jp      set_slotreg
;013Eh RDVDP Read VDP status.
        org       $013E
        jp      vdp_stat_in

;setpag  org       $013d
;        ret

;0141h SNSMAT check key mathrics
snsmat  org       $0141
        jp      in_keyboard

;0145h RSTPLT
rstplt  org       $0145
        ret

;0149h RSTPLT?
rstplt  org       $0149
        ret

getplt  org       $014d
        ret

beep    org       $017d
        ret

prompt  org       $0181
        ret

newpad  org       $01ad
        ret

chgmdp  org       $01b5
        ret

knjprt  org       $01bd
        ret

redclk  org       $01f5
        ret

wrtclk  org       $01f9
        ret

; system

chgsnd  org       $0135
        nop
        ret
phydio  org       $0144
        ret
format  org       $0147
        ret
chkdev  org       $014a
        ret
;prtout  org       $014d
;        ret
kilbuf  org       $0156
        ret
calbas  org       $0159
        ret
subrom  org       $015c
        ret
extrom  org       $015f
        ret
eol     org       $0168
        ret
bigfil  org       $016b
        ret
nsetrd  org       $016e
        ret
nstwrt  org       $0171
        ret
nrdvrm  org       $0174
        ret
rdres   org       $017a
        ret

chgcpu  org       $0180
        ret
getcpu  org       $0183
        ret
pcmply  org       $0186
        ret
pcmrec  org       $0189
        ret

; -------------------
; start up (reset) code
; -------------------

        org $0200
soft_reset
        ex (sp),hl
        ld (LASTSTAC),hl

        ld  hl,$0000
        add hl,sp
        ld (SP_REGS),hl

        ld hl,$f300

; initialize slot
        xor a
        out (PSL_STAT),a

; initialize other interface.
        ld a,$82
        out (PPI_REGS),a
        ld a,$50
        out (GIO_REGS),a

; memory check and select slot to the memory.
        ld bc,$0303
chk_wrt_ram   ; check RAM on page3.
        ld a,c
        rrca
        rrca
        ; BB000000
        out (PSL_STAT),a

        ld a,b
        rrca
        rrca
        ld (SSL_REGS),a
        ld e,a
        ld a,$12
        ld ($f000),a
        ld a,($f000)
        cp a,$12
        jr nz,cant_wrt
        jp ram_ok
cant_wrt
;        ld a,b
;        or a,c
;        jp z,hang_up_mode
        djnz chk_wrt_ram
        dec c
        jr nz,chk_wrt_ram
        jp hang_up_mode

ram_ok
        ld a,e
        ld (EXP_TBL),a

; you can write the memory.



;----------------------
;start UserInterface ...
;----------------------
; set stack -> $f300
        ld hl,$f300
        ld sp,hl


        call check_rom

        call slot_clear

        call init_ram
        call init_vdp

        xor  a,a
        ld   (PSG_DBG),a

        call sound_init
                
        ei

        halt
        call disp_info
        call start_cartprog

;----------------------
;Start GAME
;----------------------
start_game
        ld hl,stack_error
        push hl
        ld hl,($4002) ; Cartridge Start Address
        jp (hl)     ; Running ...


;-------------------------------
; display infomation 
;-------------------------------
disp_info

; if press shift key then goto debug_mode
;
        ld   a,$06
        call in_keyboard
        bit  0,a
        jp   z,debug_mode


; display program infomation

        ld hl,str_proginfo   ; HL = string address
        call prn_text

        in   a,(PSL_STAT)
        and  a,$0C
        ret  nz
        ld   hl,str_nocart
        call prn_text

        jp   hang_up_mode


;----------------------------
start_cartprog
; if can see cartridge then run the program in slot.
        ld   hl,str_thanks
        call prn_text

        ld   hl,str_slot
        call prn_text

        in   a,(PSL_STAT)
        rrca
        rrca
        and  $03
        call vout_hex8

        call check_sum

        ld   a,(SMOD_TSTSND)
        or   a,a
        jr   z,stst_skip
        ld   hl,str_canstst
        call prn_text

stst_skip
        ld   b,120  ; 2sec wait (1 = 1/60sec)
        call wait_key07 ; wait routine 

        bit  7,a
        call z,sound_mode
        bit  0,a
        jp   z,debug_mode
        bit  1,a
        jr   nz,skip_msg

; check press ctrl key, display secret infomation.

        ld   hl,str_secretmsg
        call prn_text

skip_msg
        ld  hl,str_run
        call prn_text

        call dbg_reg

        ld b,60 ; 1sec
        call wait_b

        ret

; ------
; BIOS Debug routines
; ------
sh_debug
        ex (sp),hl
        ld (LASTSTAC),hl

debug_mode
        ; return the hook. 
        ld   a,$C9
        ld   (H.KEYI),a
        ld   (H.TIMI),a

        call init_vdp

        ld   hl,$4000 ; this address is start of Page1  
        ld   (DISPADDR),hl 

        ld   hl,$0000
        call vdp_setwrt

        ld   ix,(LASTSTAC)
        call vout_hex16

        ld   a,' '
        out  (VDP_DATA),a

        ld   ix,(SP_REGS)
        call vout_hex16
loop_dump
        call disp_dump
        call dump_keywait
        jr loop_dump


;-----------------
; dump_program sub-routines.
;-----------------

disp_dump

        ld   hl,40
        ld   de,hl   ; DE = current text position
        ld   ix,(DISPADDR)
        ld   c,$10   ; RegC = rows

dump_lp
        ld   hl,40
        add  hl,de
        ld   de,hl

        call vdp_setwrt

        push bc
        call vout_hex16
        pop  bc
        ld   a,' '
        out  (VDP_DATA),a
        nop
        nop
        ld   a,':'
        out  (VDP_DATA),a
        nop
        nop
        ld   a,' '
        out  (VDP_DATA),a
        nop
        nop
        ld   b,$10   ; RegB = cols
d16_lp
        ld   a,(ix)
        push bc
        call vout_hex8
        pop  bc
        inc  ix
        djnz d16_lp

        dec  c
        jr   nz,dump_lp

        ret

;-------------------------
; Wait of KeyloopRoutine
dump_keywait

        ld   e,$02

        ld   a,($E008)
        ld   d,a 

        ld   a,$08
        call in_keyboard

        cp   a,d
        jr   z,dumpkey_loop
        ; case of A != E008
        ld   ($E008),a
        ld   e,$10  ; 

dumpkey_loop
        halt
        ld   a,($E008)
        ld   d,a 

        ld   a,$08
        call in_keyboard

        dec  e
        jr   z,skip_kchk
        cp   a,d
        jr   z,dumpkey_loop

skip_kchk
        bit  7,a
        jr   z,on_pagedown
        bit  6,a
        jr   z,on_down
        bit  5,a
        jr   z,on_up
        bit  4,a
        jr   z,on_pageup

        ld   ($E008),a

        ld   a,$07
        call in_keyboard

        bit  1,a
        jr   z,on_start

        jp   dumpkey_loop

on_pagedown
        ld  bc,$100
        jr  up_addr
on_pageup
        ld  bc,$100
        jr  down_addr
on_down
        ld  bc,$10
        jr  up_addr
on_up
        ld  bc,$10
        jr  down_addr

up_addr
        ld  hl,($E010)
        add hl,bc
        ld  ($E010),hl
        ret
down_addr
        ld  hl,($E010)
        and a
        sbc hl,bc
        ld  ($E010),hl
        ret

on_start
        jp start_game


;--------------------
;initialize VDP routine
;--------------------

init_vdp
        in a,(VDP_STAT) ; reset Latch 
        ld bc,$0000  ; R#0
        call wrt_vdp
        ld bc,$7001  ; R#1
        call wrt_vdp 
        ld bc,$0002  ; R#2  
        call wrt_vdp
        ld bc,$0104  ; R#4  
        call wrt_vdp

        call clr_text40

        ld a ,$00
        ld bc,$0800
        ld hl,$0800
        call vdp_fillmem



; PatGenTbl
;        76543210 76543210
;        00000100 00000000
;             04h      00h

        ld   bc,$F507  ; R#7
        call wrt_vdp

        in   a,(VDP_STAT) ; reset Latch

        ld   hl,MFonts

        ld   de,$800
        ld   bc,$800
        call vdp_data_rep

        ; screen 2 initial address.
        ld   hl,$1800
        ld   (GRPNAM),hl
        ld   hl,$2000
        ld   (GRPCOL),hl
        ld   hl,$0000
        ld   (GRPCGP),hl
        ld   hl,$1B00
        ld   (GRPATR),hl
        ld   hl,$3800
        ld   (GRPPAT),hl

        ret

;------------------------
; Clear Text
clr_text40
        xor  a,a
        ld   bc,$0800
        ld   hl,$0000
        call vdp_fillmem
        xor  a,a
        ld  (CSRY),a
        ld  (CSRX),a
        ret

;-----------------------
;cursor set to point.
;in ... RegB = X, RegC = Y
curxy
        ld  a,c
        ld  (CSRY),a
        ld  a,b
        ld  (CSRX),a
        ret
    

;------------------------
; initialize RAM

init_ram
        ld   a,$C9 ; ret code
        ld   hl,H.KEYI
        ld   (hl),a
        ld   de,H.KEYI+1
        ld   bc,$024D
        ldir

        ld   a,$FF 
        ld   hl,OLDKEY
        ld   (hl),a
        ld   de,OLDKEY+1
        ld   bc,22
        ldir

        ld   hl,$8000
        ld   (BOTTOM),hl  ; ?????

        ld   hl,m_rdprim
        ld   de,$F380
        ld   bc,m_prim_end-m_rdprim
        ldir

        ret


;------------------------
;
;display register
;
dbg_reg
        push ix
        push iy
        push hl
        push de
        push bc
        push af

        ld iy,6

        ld hl,40*15
        call vdp_setwrt

dbg_loop  ; loop until pop all stack.
        pop ix
        call prn_hex

        dec iy
        ; ld  bc,iy
        push iy
        pop  bc

        xor a,a
        or  a,c

        jp nz,dbg_loop
        pop  ix
        push ix
        jp prn_hex ; Print PC


;------------------------
prn_hex
;BC = Reg
        call prn_reg
        call vout_hex16

        nop
        nop
        ld a,' '
        out (VDP_DATA),a

        ret

;------------------------
prn_reg
;
        push hl
        push bc
        push iy
        pop  bc
        ;ld  bc,iy
        ld  a,c
        add a,a
        add a,a
        ld  c,a
        
        ld  hl,reg_tbl
        add hl,bc

        ld b,$03
        ld c,VDP_DATA
        otir

        pop bc
        pop hl
        ret

;------------------------
vout_hex16
; display word scale hex number.
;IX = number
;dest = BC,HL,AF
        ; RegB upper 4bit
        ld      hl,hex_tbl
        ;ld     bc,ix
        push    ix
        pop     bc

        ld      a,b
        rlca
        rlca
        rlca
        rlca
        and     a,$0F

        ld      b,0
        ld      c,a
        add     hl,bc
        ld      a,(hl)
        out     (VDP_DATA),a

        ; RegB lower 4bit
        ld      hl,hex_tbl
        ;ld     bc,ix
        push    ix
        pop     bc

        ld      a,b
        and     a,$0F

        ld      b,0
        ld      c,a
        add     hl,bc
        ld      a,(hl)
        out     (VDP_DATA),a

        ; RegC upper 4bit
        ld      hl,hex_tbl
        ;ld     bc,ix
        push    ix
        pop     bc

        ld      a,c
        rlca
        rlca
        rlca
        rlca
        and     a,$0F

        ld      b,0
        ld      c,a
        add     hl,bc
        ld      a,(hl)
        out     (VDP_DATA),a

        ; RegC lower 4bit
        ld      hl,hex_tbl
        ;ld     bc,ix
        push    ix
        pop     bc

        ld      a,c
        and     a,$0F

        ld      b,0
        ld      c,a
        add     hl,bc
        ld      a,(hl)
        out     (VDP_DATA),a

        ret

;------------------------
vout_hex8
; display byte scale hex number.
;A = number
;dest = BC,HL,AF
        push    af ; this stack is use to lower 4bits.

        ; RegA upper 4bit
        ld      hl,hex_tbl
        rlca
        rlca
        rlca
        rlca
        and     a,$0F

        ld      b,0
        ld      c,a
        add     hl,bc
        ld      a,(hl)
        out     (VDP_DATA),a

        pop     af

        ; RegA lower 4bit
        ld      hl,hex_tbl

        and     a,$0F

        ld      b,0
        ld      c,a
        add     hl,bc
        ld      a,(hl)
        out     (VDP_DATA),a

        ret


;------------------------
; wait routine.
;CAUTION!!
; set always EI.
; B = counter of loop
wait_b
        halt
        djnz    wait_b
        ret

;------------------------
; wait routine.
;CAUTION!!
; set always EI.
; in .... B = counter of loop.
; out ... A = 7th key mathrics.
; dest .. RegC
wait_key07
        ld    c,$ff
wk07_lp
        halt
        ld    a,($FBEB)
        and   a,c
        ld    c,a
        djnz  wk07_lp
        ld    a,c
        ret

;------------------------
;prn_text
; HL = string

prn_text
        call curs2de
prn_text_lp
        call prn_str

        ; store 1line

        push    hl   
        ld      hl,de
        ld      de,40
        add     hl,de
        ld      de,hl
        pop     hl

        inc     hl
        cp      (hl)
        jp      nz,prn_text_lp
        call    de2curs
        ret


;------------------------

prn_str
        ex      hl,de
        call    vdp_setwrt
        ex      hl,de

prn_str_disp
; dest... af
; out ... hl = termination point 
        di
prn_str_disp_lp
        ld      a,(hl)
        or      a,a
        jp      z,nul_term
        out     (VDP_DATA),a
        inc     hl
        jr      prn_str_disp_lp
nul_term
        ei
        ret


; -------------------------
; check cartridge in slot.
; -------------------------
set_page2
; set slot value to page2.
; in: RegBC = slot.

        ld  a,b
        rlca
        rlca
        ; 0000BB00

        ld  d,a 
        in  a,(PSL_STAT)
        and a,$F3
        or  a,d
        out (PSL_STAT),a

        ld  hl,SSL_REGS
        ld  a,c
        rlca
        rlca
; (TBL&0xC3) | c<<2 = A 
        ld  d,a
        ld  a,(EXP_TBL)
        and a,$F3
        or  a,d

        ld (hl),a
        ret

check_rom
; RegB = the value of primary slot.
; RegC = second slot.

        ld bc,$0000
chk_rom_loop
        call set_page2

        ld a,($4000)
        cp a,'A' 
        jr nz,no_cart

        ld a,($4003)
        cp a,$40
        jr m,no_cart ; A-$40 < 0
        cp a,$80
        jr p,no_cart ; A-$80 >= 0

        jp chk_rom_ok 
no_cart
        inc c
        ld  a,$03        ; maximum slot number.
        cp  a,c
        jr  nz,chk_rom_loop 

        inc b
        ld  c,0
        cp  a,b
        jr  p,chk_rom_loop ; A-B >= 0
        ; could'nt found the cartridge.
chk_rom_ng

        ld bc,$0000
        call set_page2

chk_rom_ok
        ret

;-------------------------------------
;convert cursor to RegDE
;-------------------------------------
;out.. DE = VRAM address.
curs2de
        push af
        push bc
        push hl

        ld   de,40    ; text40 
        ld   hl,$0000

        ld   a,(CSRY)
        or   a,a
        jr   z,c2d_add_skip
        ld   b,a
c2d_add_lp
        add  hl,de
        djnz c2d_add_lp
c2d_add_skip
        ld   a,(CSRX)
        ld   e,a
        add  hl,de

        ld   de,hl

        pop  hl
        pop  bc
        pop  af
        ret
;-----------------------------------

de2curs
        push af
        push bc
        push de
        push hl

        ; 256 - 16 = 240
        ld   hl,de
        ld   bc,40
        ld   de,$0000
        jr   under_chk
d2c_sub_lp
        and  a
        sbc  hl,bc
        inc  e
under_chk
        xor  a,a
        cp   a,h
        jr   nz,d2c_sub_lp
        ld   a,l
        cp   a,40
        jr   p,d2c_sub_lp

        ld   (CSRX),a
        ld   a,e
        ld   (CSRY),a

        pop  hl
        pop  de
        pop  bc
        pop  af
        ret



;----------------------------------
rdprim equ $F380
wrprim equ rdprim+(m_wrprim-m_rdprim)
clprim equ rdprim+(m_clprim-m_rdprim)
cl_jp  equ rdprim+(m_cl_jp-m_rdprim)

m_rdprim
        out (PSL_STAT),a
        ld  e,(hl)
        jr  m_wrprm1
m_wrprim
        out (PSL_STAT),a
        ld  (hl),e
m_wrprm1
        ld  a,d
        out (PSL_STAT),a
        ret
m_clprim
        out (PSL_STAT),a
        ex af,af'
        call cl_jp
        ex af,af'
        pop af
        out (PSL_STAT),a
        ex af,af'
        ret
m_cl_jp
        jp (ix)
m_prim_end
        nop

; --------------------------
; sub-routine
;---------------------------
; 000Ch RDSLT
; in ..  A = slotID , HL = Address
rdslt
        
        push hl
        push af

        ld   a,h
        rlca
        rlca
        and  a,$03 ; address upper 2bit

        ld   l,a  ; L=shift number
        ld   b,a

        ld   a,$03
        call rdsft
        cpl
        ld   e,a ; E= MASK
        ld   a,l ; A=shift#
        ld   b,a ; B=shift#
        pop  af
        and  a,$03
        call rdsft
        ld   b,a ; B=shifted slot
        in   a,(PSL_STAT)
        ld   d,a  ; D=old psl
        and  a,e
        or   a,b  ; changed slot
        pop  hl

        call   rdprim
        ld   a,e
        ret

rdsft
        inc b
        dec b
        ret z
rdsft_lp
        rlca
        rlca
        djnz rdsft_lp
        ret


; 001Ch CALSLT(conditional function)
; in .. IYh(SlotNumber),(IX)
cal_slt
        jp (ix)

;--------------------------------
; 0020h DCOMPR
; in .. hl,de= number
wordcomp
        ld a,h
        cp a,d
        ret nz
        ld a,l
        cp a,e
        ret


;--------------------------------
; 0024h ENASLT
; in .. hl=Address,a=slotnumber
; A = FxxxEESS
; RegA detail 
; F = Flag of Extended slot.
; E = Extended slot#
; S = slot#

slt_set

; A=(A >> 6)&0x3

        push af
        ld   a,h
        rlca
        rlca
        and  a,$03 ; H=upper 2bit
        ld   h,a
        pop  af
        push af

;       

        call p_slot
        pop  af
        push de
        and  a,a
;           jp   p,s_slot
        pop  de
        in  a,(PSL_STAT)
        and a,d
        or  a,e
        out (PSL_STAT),a

        ret

p_slot
        ld   d,a   ; D = slot#
        rrca
        rrca
        and  a,$C0 ; SS000000
        ld   b,h   ; B = page#
        inc  b
ps_lp1
        rlca
        rlca
        djnz ps_lp1

        ld  e,a   ; E = shifted slot#

        ld   b,h
        inc  b
        ld   a,$C0 ; a=MASK
ps_lp2
        rlca
        rlca
        djnz ps_lp2

        cpl

        ld  d,a   ; B = ~MASK
        
        ret


;--------------------------------
; 0030h CALLLF
call_lf
        pop hl ; Address of SlotInfo
        ld  a,(hl)
        inc hl
        ld  e,(hl)
        inc hl
        ld  d,(hl)
        inc hl
        ex  hl,de
        push de
        push hl
        push af
        call slt_set
        pop  af
        pop  hl
        jp (hl)


;--------------------------------
; 0050h SETRD
vdp_setrd
        di
        ld  a,l
        out (VDP_ADDR),a
        ld  a,h
        and a,$3f
        out (VDP_ADDR),a
        ei
        ret

;--------------------------------
; 0053h SETWRT
; set VRAM Address
vdp_setwrt
        di
        ld  a,l
        out (VDP_ADDR),a
        ld  a,h
        and a,$3f
        or  a,$40
        out (VDP_ADDR),a
        ei
        ret

;--------------------------------
;0056h fill VRAM
;HL = VRAM address, BC = length , A = data
vdp_fillmem
        push af
        call vdp_setwrt
lp_u001
        pop af
        out (VDP_DATA),a
        push af

        dec  bc
        ld   a,c
        or   b
        jr   nz,lp_u001
        pop af
        ret

;--------------------------------
wrt_vdp 
; 0047h WRTVDP
;in:B = VDP Data , C = Reg#
        push hl
        di
        ld a,b
        out (VDP_ADDR),a
        ld a,c
        or a,$80
        out (VDP_ADDR),a
        ei
        ld a,b
        ld b,0
        ld hl,RG0SAV
        add hl,bc
        ld (hl),a
        pop hl
        ret

;--------------------------------
;004Ah Read VRAM
rd_vrm
        call vdp_setrd
        ex (sp),ix
        ex (sp),ix
        in a,(VDP_DATA)
        ret


;--------------------------------
;004Dh Write VRAM
wrt_vrm
        push af
        call vdp_setwrt
        ex (sp),ix
        ex (sp),ix
        pop  af
        out (VDP_DATA),a
        ret

;--------------------------------
vdp_ldirmv
	call	vdp_setrd
	ex	(sp),ix
	ex	(sp),ix
ldir_lp1
	in	a,(VDP_DATA)
	ld	(de),a
	inc	de
	dec	bc
	ld	a,c
	or	b
	jr	nz,ldir_lp1
	ret

;--------------------------------
vdp_reg1chk
        ld a,(RG1SAV)
        rrca
        rrca
        ld      a,$08
        ret     nc
        ld      a,$20
        ret

;--------------------------------
vdp_data_rep
        ex de,hl
        call vdp_setwrt
lp_vd_rep
        ld      a,(de)
        out     (VDP_DATA),a
        inc     de
        dec     bc
        ld      a,c
        or      b
        jr      nz,lp_vd_rep
        ret

;--------------------------------
;0072h INIGRP
init_grp
        ld a,$02
        ld (SCRMOD),a

        in a,(VDP_STAT) ; reset Latch

        ld  a,(RG0SAV)
        or  a,2
        and a,$f3
        ld  b,a
        ld  c,0
        call wrt_vdp ; VDP R#0
        inc  c
        ld   a,(RG1SAV)
        and  $e7
        ld   b,a
        call wrt_vdp ; VDP R#1
        ld   hl,($F3C7)
        call vdp_setwrt
        ld   b,3
        xor  a
ig_loop
        out  (VDP_DATA),a
        inc  a
        jr   nz,ig_loop
        djnz ig_loop

;        ld  hl,($F3C9)
;        ld  hl,($F3CB)

        ld  hl,($F3CD)
        ld  ($F928),hl
        ld  hl,($F3CF)
        ld  ($F926),hl
        ; I want to write clear sprites and graphics
        ld  hl,$F3C7
        ld  de,$7F03
        call set_grp
        call enascr
        ret

; HL = Address of table
; B  = DATA , C = VDP R#
; DE = VDPDATA
set_grp
        ld   bc,$0602 ; B= shift count C = R#
        xor  a,a
        call adr_sft
        ld   b,10
        ld   a,d
        call adr_sft
        ld   b,5
        ld   a,e
        call adr_sft
        ld   b,9
        xor  a,a
        call adr_sft
        ld   b,5
        xor  a,a
        call adr_sft
        ret
adr_sft
        push hl
        push af
        ld   a,(hl)
        inc  hl
        ld   h,(hl)
        ld   l,a
sft_lp
        add  hl,hl
        adc  a,a
        djnz sft_lp
        ld   h,a
        pop  af
        or   h
        ld   b,a
        call wrt_vdp
        pop  hl
        inc  hl
        inc  hl
        inc  c
        ret

;005Fh CHGMOD
chgmod
        or a,a
        ; jp z,init_text
        dec a
        ; jp z,init_txt32 
        dec a
        jp z,init_grp
        dec a
        ;jp z,init_mlt
        ret

;0062h CHGCLR
;in = none
chgclr
        ld  a,(SCRMOD)
        dec a
        push af
        ld a,(BDRCLR)
        ld b,a
        ld c,7
        call vdp_setwrt
        pop af
        ret nz

        ld  a,(FORCLR)
        add a,a
        add a,a
        add a,a
        add a,a
        ld  hl,BAKCLR
        or  (hl)
        ld  hl,($F3BF)
        ld  bc,$0020
        push af
        call vdp_setwrt
cclr_lp pop af
        out (VDP_DATA),a
        push af
        dec bc
        ld  a,b
        or  c
        jr  nz,cclr_lp
        pop af
        ret

;0044h ENASCR
enascr
        in a,(VDP_STAT) ; reset Latch

        ld a,(RG1SAV)
        or a,$40
        ld b,a
        ld c,1
        call wrt_vdp
        ret

;00?? DISSCR
disscr
        in a,(VDP_STAT) ; reset Latch

        ld   a,(RG1SAV)
        and  a,$BF
        ld   b,a
        ld   c,1
        call wrt_vdp
        ret


;--------------------------------
;009Ch  CHSNS
ch_sns
        ld a,$00
        and a
        ret
        
;--------------------------------
;0090h GICINIT initialize sound ic
sound_init
        ld e,$00
        ld a,$08
        call sound_out
        inc a
        call sound_out
        inc a
        call sound_out
        inc a

        ld e,$b8
        ld a,$07
        call sound_out
        ret

;--------------------------------
;0093h in a=reg#,e=data
sound_out
        di
        out   (PSG_REGS),a
        push  af
        ld    a,e
        out   (PSG_DATA),a
        ei
        pop   af
        push  af
        push  de
        ld    d,a
        ld    a,(PSG_DBG)
        or    a,a
        call  nz,disp_psg
        pop   de
        pop   af
        ret

;--------------------------------
sound_stat
        out (PSG_REGS),a
        in a,(PSG_STAT)
        ret

;--------------------------------
get_slotreg
        in a,(PSL_STAT)
        ret

;--------------------------------
set_slotreg
        out (PSL_STAT),a
        ret

;--------------------------------
; 013Eh 
vdp_stat_in
        in a,(VDP_STAT)
        ret

;--------------------------------
;0141h SNSMAT
in_keyboard
        di
        ld  c,a
        in  a,(GIO_REGS)
        and a,$F0
        or  a,c
        out (GIO_REGS),a
        in  a,(KBD_STAT)
        ei
        ret

;--------------------------------
;00D5h GTSTCK
; a = InID...
in_joy
        cp a,$00
        jr nz,joy_end
        ld   a,$08
        call in_keyboard
        rrca
        rrca
        rrca
        rrca
        cpl
        and  a,$0f ; 0000RDUL
       
        ld   hl,joypos_tbl
        ld   b,0
        ld   c,a
        add  hl,bc
        ld   a,(hl)
        ret
joy_end
        ld a,$00
        ret

joypos_tbl
        ;    0   1   2   3   4   5   6   7
        db $00,$07,$01,$08,$05,$06,$00,$00
        ;    8   9   A   B   C   D   E   F
        db $03,$00,$02,$00,$04,$00,$00,$00


;--------------------------------
;00D8h GTTRIG
in_trig
        cp a,$00
        jr z,space_mode
        xor a
        ret
space_mode
        ld   a,$08
        call in_keyboard
        and  a,$01
        jr   z,trig_sp
        xor  a
        jr   trig_end
trig_sp
        ld   a,$FF
trig_end
        ret

;--------------------------------
slot_clear
        xor a
        ld hl,$fcc2
        ld (hl),a
        inc hl
        ld (hl),a
        inc hl
        ld (hl),a
        ret
;------------------
; interrupt routine code
;------------------

int_start
; for debug...
;        push    hl
;        ld  hl,$3232
;        ex (sp),hl
; 
        push    hl
        push    de
        push    bc
        push    af
        exx  
        ex      af,af'
        push    hl
        push    de
        push    bc
        push    af
        push    iy
        push    ix

        call   H.KEYI
        in a,(VDP_STAT)
        or a
        jp p,int_end

        call H.TIMI
        ei
        ld (STATFL),a ; save status

        xor a
        ld  (CLIKFL),a
        call in_trig
        cpl
        and a,$01
        ld ($F3E8),a
        call old_key
        call key_in

int_end
        pop ix
        pop iy
        pop af
        pop bc
        pop de
        pop hl
        exx
        ex af,af'
        pop af
        pop bc
        pop de
        pop hl
        ei
        ret

;--------------------------------
; 0066h NMI Interrupt
nmi_int
        call H.NMI
        retn

;--------------------------------
old_key
        ld de,NEWKEY
        ld hl,OLDKEY
        ld b,$0b
oldkey_lp
        ld a,(de)
        ld (hl),a
        inc de
        inc hl
        djnz oldkey_lp
        ret

;--------------------------------
key_in
        in  a,(GIO_REGS)
        and a,$F0
        ld  c,a
        ld  b,$0b
        ld  hl,NEWKEY
key_in_lp
        ld  a,c
        out (GIO_REGS),a
        in  a,(KBD_STAT)
        ld (hl),a
        inc hl
        inc c
        djnz key_in_lp
        ret

;--------------------------------
key_int
        ld  hl,NEWKEY
        ld  bc,$0006
        add hl,bc
        ld a,(hl)
        and a,$01
        jr nz,ki_end
        call dbg_reg
ki_end
        ret

;-------------------
        org $1000
hang_up_mode
        halt
        jp hang_up_mode

        org $1010
stack_error
        call H.STKE
        jp hang_up_mode

str_proginfo
;           0123456789012345678901234567890123456789 
        db "MSX COMPATIBLE BIOS ver 0.05",$00
        db "Copyright (C) 2002 BouKiCHi",$00
        db $00

str_secretmsg
        db " ",$00
        db "KOGA RYOUICHI SENSEI NO [GENOME] HA",$00
        db "SUGOKU OMOSHIROI YO!",$00
        db " ",$00,$00

str_thanks
        db " ",$00
        db "special thanks ...",$00
        db "http://retropc.net/",$00
        db "http://www.vorc.org/",$00
        db " ",$00
        db $00

str_slot
        db "slot:",$00,$00
str_chksum
        db "checksum:",$00,$00
str_isgame
        db " game:",$00,$00

str_canstst
        db "SOUND TEST [F3 Key]",$00,$00

str_nocart
;           0123456789012345678901234567890123456789 
        db " ",$00
        db "        Cartridge not found.",$00
        db $00

str_run
;          [0123456789012345678901234567890123456789] 
        db " ",$00
        db "           Starting...",$00
        db $00

str_s_test
;          [0123456789012345678901234567890123456789] 
        db " ",$00
        db "           SOUND TEST MODE",$00
        db $00

str_testchrs
        db " (^^; m(_ _)m (ToT)",$00
        db "ABCDEFGHIJKLMNOPQRSTUVWXYZ",$00
        db "abcdefghijklmnopqrstuvwxyz",$00
        db "0123456789",$00
        db $00
hex_tbl
        db "0123456789ABCDEF",$00
reg_tbl
        db "PC: IY: IX: HL: DE: BC: AF: ",$00

;--------------------------
; the routines of sound test. 
;--------------------------

        org $2000

sound_mode
        di

        ld      a,$FF
        ld      (PSG_DBG),a

        
        in      a,(PSL_STAT)
        rrca
        rrca
        and     $03             ; A=CART ROM slot

        ld      hl,$8000
        call    slt_set         ; duplicate page1 to page2

        ; takeover the hook.
        ld      a,$C9
        ld      (H.KEYI),a
        ld      (H.TIMI),a

        call    clr_text40

        ; display zero.
        xor     a,a
        ld      de,$0000

        ld      b,$10
pdsp_lp
        call    disp_psg
        inc     d
        djnz    pdsp_lp


        ld      hl,str_s_test
        call    prn_text

        call    chk_mus_lst

        call    sndmod_play

        xor     a,a
        ld      (SMOD_OLDKEY),a

;-----------------------------
; sound routine main loop
snd_loop
        halt
        ld      hl,(SMOD_PLAY)
        call    call_hl

        ld      a,$08
        call    in_keyboard
        ld      b,a
        ld      a,(SMOD_OLDKEY)
        cp      a,b
        jr      z,snd_loop
        ld      a,b
        ld      (SMOD_OLDKEY),a

        bit     6,a
        jr      z,snd_down
        bit     5,a
        jr      z,snd_up
        bit     0,a
        jp      z,debug_mode
        jp      snd_loop

;--------------------------
snd_down
        ld      a,(SMOD_REQNUM)
        inc     a
        jr      snd_set
snd_up
        ld      a,(SMOD_REQNUM)
        dec     a
snd_set
        call    chk_snd_rng
        ld      (SMOD_REQNUM),a
        call    sndmod_play
        jr      snd_loop

;---------------------------
; check range of request number.
chk_snd_rng
; dest AF,HL,B
        ; check music list.
        ld      b,a
        ld      hl,(SMOD_MUSLST)
        ld      a,h
        or      a,a
        jr      nz,m_lst_rng
        ld      a,b
        ret
m_lst_rng
        ld      hl,(SMOD_MUSLST)
        ld      a,(hl) ; A=6 A>B
        cp      a,b
        jr      c,m_rng_ng
        ld      a,b
        ret
m_rng_ng
        ld      a,(SMOD_REQNUM)
        ret

;----------------------
chk_mus_lst
        ; check music list.
        ld      hl,(SMOD_MUSLST)
        ld      a,h
        or      a,a
        jr      nz,m_list_fnd

        ld      a,l ; L=REQNO
        ld      (SMOD_REQNUM),a
        ret
m_list_fnd
        ld      a,$00
        ld      (SMOD_REQNUM),a
        ret

;---------------------------
sndmod_play
        call    sound_memclr


        ld      hl,(SMOD_MUSLST)
        ld      a,h
        or      a,a
        jr      z,sndmod_hex

        push    hl
        pop     ix
        inc     ix

        ld      a,(SMOD_REQNUM)

        ld      b,0
        ld      c,a
        add     ix,bc
        add     ix,bc
        add     ix,bc
        add     ix,bc

        call    set_name_adrs

        ld      l,(ix+2)
        ld      h,(ix+3)

        call    prn_str_disp
        ld      a,(ix)

        ld      hl,(SMOD_INIT)
        call    call_hl
        ret

sndmod_hex
        call    set_name_adrs
        ld      a,(SMOD_REQNUM)
        call    vout_hex8
        ld      a,(SMOD_REQNUM)

        ld      hl,(SMOD_INIT)
        call    call_hl
        ret

;---------------------------
call_hl
        jp      (hl)

;------------------------
set_name_adrs
        ld      hl,120
        call    vdp_setwrt
        di
        xor     a,a
        ld      bc,(wrvdpa)
        ld      b,40
fill_rep
        out     (c),a
        djnz    fill_rep

        ei
        ld      hl,128
        call    vdp_setwrt
        ret


sound_memclr
        xor     a,a
        ld      hl,$c000
        ld      de,$c001
        ld      bc,$3000
        ld      (hl),a
        ldir
        ret

disp_psg
        push    hl
        push    de
        push    bc
        push    af

        ld      h,0
        ld      l,d
        ld      bc,320

        add     hl,hl
        add     hl,hl

        add     hl,bc

        call    vdp_setwrt

        ld      a,e

        call    vout_hex8

        pop     af
        pop     bc
        pop     de
        pop     hl
        ret


;-------------------------
check_sum
        xor     a,a
        ld      bc,$4000
        ld      hl,$4000
        ld      de,$0000
csum_lp
        ld      a,(hl)
        add     a,e
        ld      e,a
        jr      nc,csum_nc
        inc     d
csum_nc
        inc     hl
        dec     bc

        ld      a,b
        or      a,c
        jr      nz,csum_lp

        ;DE = checksum

        push    de

        ld      hl,str_chksum
        call    prn_text

        pop     ix
        push    ix

        call    vout_hex16

        ld      hl,str_isgame
        call    prn_str_disp

        pop     hl
        ld      (SMOD_ROMSUM),hl
        ld      bc,$000A     ; size of one structure.

        ld      ix,sum_table
cs_nam_loop
        ld      a,(ix)
        or      a,(ix+1)
        jr      z,cs_nam_skip


        ld      a,(ix)
        cp      a,l
        jr      nz,cs_nam_next
        ld      a,(ix+1)
        cp      a,h
        jr      nz,cs_nam_next

        jr      cs_nam_skip

cs_nam_next
        add  ix,bc
        jr   cs_nam_loop
cs_nam_skip

        ld   a,(ix+4)
        ld   l,a
        ld   a,(ix+5)
        ld   h,a
        ld   (SMOD_MUSLST),hl

        ld   a,(ix+6)
        ld   l,a
        ld   a,(ix+7)
        ld   h,a
        ld   (SMOD_INIT),hl

        ld   a,(ix+8)
        ld   l,a
        ld   a,(ix+9)
        ld   h,a
        ld   (SMOD_PLAY),hl

        ld   a,(ix+2)
        ld   l,a
        ld   a,(ix+3)
        ld   h,a

        call prn_str_disp
        inc  hl
        ld   a,(hl)
        ld   (SMOD_TSTSND),a
        ret


;-----------------------------

sum_table
            ;CSUM,PTR_GAMENAME,LIST_MUSIC  ,INIT ,PLAY
            ;------------------------------------------
        dw  $0d0f,name_goonies,list_mus_gns,$B590,$B641
        dw  $b49f,name_zanac  ,$0000       ,$0000,$0000
        dw  $9ae8,name_kungfu ,$0000       ,$0000,$0000
        dw  $008f,name_g1942  ,$0000       ,$0000,$0000
        dw  $665a,name_pooyan ,$0000       ,$0000,$0000
        dw  $0000,name_unknown,$0000       ,$0000,$0000 ; NULL
name_goonies
        db "GOONIES",$0,$FF
name_zanac
        db "ZANAC",$0,$0
name_kungfu
        db "KUNGFU",$0,$0
name_g1942
        db "1942",$0,$0
name_pooyan
        db "POOYAN",$0,$0
name_unknown
        db "UNKNOWN",$0,$0

list_mus_gns
        ; list length
        db $1c
        dw $009B,gns_theme   
        dw $0091,gns_mus1   
        dw $0098,gns_mus2   
        dw $00A1,gns_mus3   
        dw $00A4,gns_mus4   
        dw $00A7,gns_mus5   
        dw $00AA,gns_mus6   
        dw $0081,gns_mus7   
        dw $0085,gns_mus8   
        dw $0089,gns_mus9   
        dw $008E,gns_mus10   
        dw $0001,gns_se1
        dw $0002,gns_se2
        dw $0003,gns_se3
        dw $0004,gns_se4
        dw $0005,gns_se5
        dw $0006,gns_se6
        dw $0007,gns_se7
        dw $0008,gns_se8
        dw $0009,gns_se9
        dw $000A,gns_se10
        dw $000B,gns_se11
        dw $000C,gns_se12
        dw $000D,gns_se13
        dw $000E,gns_se14
        dw $000F,gns_se15
        dw $0010,gns_se16
        dw $0011,gns_se17
        dw $0012,gns_se18
        dw $0000,$0000   ; NULL

gns_theme
        db "THE THEME OF GOONIES",$0
gns_mus1
        db "MUSIC 1",$0
gns_mus2
        db "MUSIC 2",$0
gns_mus3
        db "MUSIC 3",$0
gns_mus4
        db "MUSIC 4",$0
gns_mus5
        db "MUSIC 5",$0
gns_mus6
        db "MUSIC 6",$0
gns_mus7
        db "MUSIC 7",$0
gns_mus8
        db "MUSIC 8",$0
gns_mus9
        db "MUSIC 9",$0
gns_mus10
        db "MUSIC 10",$0


gns_se1
        db "S.E.1",$0
gns_se2
        db "S.E.2",$0
gns_se3
        db "S.E.3",$0
gns_se4
        db "S.E.4",$0
gns_se5
        db "S.E.5",$0
gns_se6
        db "S.E.6",$0
gns_se7
        db "S.E.7",$0
gns_se8
        db "S.E.8",$0
gns_se9
        db "S.E.9",$0
gns_se10
        db "S.E.10",$0
gns_se11
        db "S.E.11",$0
gns_se12
        db "S.E.12",$0
gns_se13
        db "S.E.13",$0
gns_se14
        db "S.E.14",$0
gns_se15
        db "S.E.15",$0
gns_se16
        db "S.E.16",$0
gns_se17
        db "S.E.17",$0
gns_se18
        db "S.E.18",$0


;------------
;new type hook routine.(for debug)
        org $3232
debug_test
        ret

        include "font01.z80"

        align
        org $3FFF
        nop
        end Start
